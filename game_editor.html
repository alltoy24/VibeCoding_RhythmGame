<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>WEB BEAT : EDITOR (Perfect Auto Sync)</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --accent: #00e5ff; --text: #eee; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; user-select: none; }
        
        #sidebar { 
            width: 320px; min-width: 320px; 
            background: var(--panel); padding: 15px; 
            border-right: 1px solid #333; 
            display: flex; flex-direction: column; gap: 12px; 
            z-index: 20; box-shadow: 2px 0 15px rgba(0,0,0,0.7);
            overflow-y: auto; max-height: 100vh;
        }
        #sidebar::-webkit-scrollbar { width: 8px; }
        #sidebar::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        #sidebar::-webkit-scrollbar-thumb:hover { background: var(--accent); }

        h2 { margin: 0 0 10px 0; color: var(--accent); border-bottom: 2px solid var(--accent); padding-bottom: 5px; font-size: 20px; text-shadow: 0 0 10px rgba(0, 229, 255, 0.3); }
        .control-group { display: flex; flex-direction: column; gap: 6px; background: #2a2a2a; padding: 10px; border-radius: 6px; border: 1px solid #333; flex-shrink: 0; }
        .group-title { font-size: 11px; font-weight: bold; color: #aaa; text-transform: uppercase; margin-bottom: 4px; }
        input, select, button { padding: 6px; background: #111; border: 1px solid #444; color: #fff; border-radius: 4px; font-size: 11px; }
        input[type="range"] { padding: 0; cursor: pointer; accent-color: var(--accent); }
        input:focus, select:focus { border-color: var(--accent); outline: none; }
        button { cursor: pointer; font-weight: bold; transition: 0.2s; text-transform: uppercase; }
        button:hover { background: #444; filter: brightness(1.2); }
        button.primary { background: var(--accent); color: #000; border: none; box-shadow: 0 0 10px rgba(0, 229, 255, 0.2); }
        button.test-btn { background: #ff0055; color: white; border: none; font-size: 14px; padding: 12px; box-shadow: 0 0 15px rgba(255, 0, 85, 0.3); }
        
        .row { display: flex; gap: 5px; align-items: center; } .row > * { flex: 1; }
        .val-label { font-size: 12px; color: var(--accent); font-weight: bold; width: 40px; text-align: right; }

        .checkbox-label { display: flex; align-items: center; gap: 8px; cursor: pointer; background: #222; padding: 8px; border-radius: 4px; }
        .checkbox-label input { width: auto; margin: 0; cursor: pointer; accent-color: #7b1fa2; }

        #editor-view { flex: 1; display: flex; flex-direction: column; position: relative; }
        /* ê¸°ì¡´ #canvas-layer, #editor-container ìŠ¤íƒ€ì¼ì„ ì°¾ì•„ì„œ ì•„ë˜ ë‚´ìš©ìœ¼ë¡œ ìˆ˜ì •/í™•ì¸ */

        #editor-container { 
            flex: 1; 
            overflow-y: scroll; /* ìŠ¤í¬ë¡¤ì€ ì—¬ê¸°ì„œ ë°œìƒ */
            background: #0a0a0a; 
            display: flex; 
            justify-content: center; 
            position: relative; /* ì¶”ê°€ */
        }

        #canvas-layer { 
            position: relative; 
            width: 400px; 
            /* heightëŠ” JSì—ì„œ ë™ì ìœ¼ë¡œ ì„¤ì •ë¨ (ì—„ì²­ ê¸¸ê²Œ) */
            background: transparent; /* ë°°ê²½ íˆ¬ëª… */
        }

        /* â˜… [í•µì‹¬] ìº”ë²„ìŠ¤ëŠ” í™”ë©´ì— ë”± ë¶™ì–´ìˆì–´ì•¼ í•¨ */
        #gridCanvas {
            position: sticky; 
            top: 0; 
            display: block;
            background: #000;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }

        #play-head { 
            position: absolute; left: 0; width: 100%; height: 2px; 
            background: #ff0055; z-index: 5; display: none; pointer-events: none; 
            box-shadow: 0 0 10px #ff0055; will-change: transform;
        }
        .lane-header { display: flex; width: 400px; margin: 0 auto; background: #222; font-weight: bold; font-size: 12px; text-align: center; border-bottom: 2px solid #444; }
        .lane-header div { flex: 1; padding: 8px 0; border-right: 1px solid #333; color: #888; }

        #game-view { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 50; display: none; flex-direction: column; align-items: center; justify-content: center; }
        #game-canvas-container { position: relative; width: 400px; height: 100%; border-left: 2px solid #333; border-right: 2px solid #333; }
        canvas.game { display: block; width: 100%; height: 100%; }
        
        #game-hud { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; pointer-events: none; z-index: 60; }
        .hud-item { flex: 1; }
        .hud-text { font-family: 'Impact', sans-serif; font-size: 32px; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); letter-spacing: 1px; }
        .hud-sub { font-size: 12px; color: #888; font-weight: bold; }
        
        #g-avg-box { position: absolute; bottom: 120px; width: 100%; text-align: center; pointer-events: none; }
        #g-avg { font-family: 'Consolas', monospace; font-size: 14px; font-weight: bold; color: #888; text-shadow: 0 0 2px #000; }
        #test-msg { position: absolute; bottom: 20px; color: #555; font-size: 12px; animation: blink 2s infinite; }
        @keyframes blink { 50% { opacity: 0.3; } }
        
        #result-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 100; display: none; flex-direction: column; align-items: center; justify-content: center; }
        .res-rank { font-family: 'Impact', sans-serif; font-size: 120px; color: #fff; text-shadow: 0 0 20px currentColor; margin-bottom: 20px; }
        .res-rank.S { color: #00e5ff; } .res-rank.A { color: #00ff00; } .res-rank.B { color: #ffff00; } 
        .res-rank.C { color: #ff8800; } .res-rank.F { color: #ff0000; }
        
        .res-info { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px 40px; font-size: 24px; font-weight: bold; margin-bottom: 40px; }
        .res-box { text-align: center; }
        .res-label { color: #888; font-size: 14px; margin-bottom: 5px; } .res-val { color: #fff; font-size: 24px; font-weight: bold; }

        .res-detail { display: flex; justify-content: space-between; width: 90%; max-width: 500px; background: rgba(255,255,255,0.05); padding: 20px; border-radius: 15px; border: 1px solid #333; }
        .detail-item { text-align: center; }
        .detail-label { font-size: 12px; font-weight: bold; margin-bottom: 5px; }
        .detail-val { font-size: 20px; color: #fff; }

        .btn-close { margin-top: 40px; padding: 15px 40px; font-size: 18px; background: #fff; color: #000; border: none; border-radius: 30px; cursor: pointer; font-weight: 900; }
        .btn-close:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(255,255,255,0.5); }

        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; display: none; flex-direction: column; justify-content: center; align-items: center; color: #00e5ff; }
        .loading-text { font-family: 'Impact'; font-size: 40px; margin-bottom: 20px; animation: blink 1s infinite; }
        .btn-start-game { padding: 15px 50px; font-size: 24px; font-weight: bold; background: #ff0055; color: white; border: none; border-radius: 50px; cursor: pointer; display: none; }
        
        input[type="file"] { display: none; }
        .file-label { display: block; padding: 8px; background: #333; text-align: center; border-radius: 4px; cursor: pointer; border: 1px dashed #666; font-size: 12px; }
        .file-label:hover { background: #444; border-color: var(--accent); color: var(--accent); }
        
        #auto-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Impact'; font-size: 80px; color: rgba(123, 31, 162, 0.3); pointer-events: none; display: none; z-index: 55; }

        /* [ìˆ˜ì •] í…ŒìŠ¤íŠ¸ ì»¨íŠ¸ë¡¤ëŸ¬ (ë“œë˜ê·¸ ê°€ëŠ¥í•˜ë„ë¡ ë³€ê²½) */
        #test-controls {
            position: absolute; 
            bottom: 50px; left: 50%; transform: translateX(-50%); /* ì´ˆê¸° ìœ„ì¹˜ */
            width: 400px; padding: 0; /* íŒ¨ë”© ì œê±° (ë‚´ë¶€ì—ì„œ ì²˜ë¦¬) */
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444; border-radius: 8px; 
            z-index: 200; /* z-index ë†’ì„ */
            display: none; flex-direction: column; 
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            overflow: hidden;
        }

        /* [ì¶”ê°€] ë“œë˜ê·¸ ì†ì¡ì´ */
        #drag-handle {
            width: 100%; height: 25px;
            background: linear-gradient(90deg, #333, #444);
            cursor: grab; display: flex; justify-content: center; align-items: center;
            border-bottom: 1px solid #555;
        }
        #drag-handle:active { cursor: grabbing; background: #00e5ff; color: #000; }
        #drag-handle span {
            width: 40px; height: 4px; background: #888; border-radius: 2px;
        }

        /* ë‚´ë¶€ ì½˜í…ì¸  íŒ¨ë”© */
        .ctrl-body { padding: 10px; display: flex; flex-direction: column; gap: 5px; }

        /* ê¸°ì¡´ ìŠ¤íƒ€ì¼ ìœ ì§€ */
        #test-controls input[type=range] { width: 100%; height: 5px; accent-color: #00e5ff; cursor: pointer; }
        .ctrl-row { display: flex; justify-content: space-between; align-items: center; }
        #time-display { font-family: 'Consolas', monospace; color: #fff; font-size: 14px; }
        .btn-group button { background: #333; border: 1px solid #555; color: #fff; padding: 5px 10px; cursor: pointer; font-size: 12px; border-radius: 4px; }
        .btn-group button:hover { background: #555; color: #00e5ff; }

    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-text" id="loading-msg">LOADING DATA...</div>
        <button id="btn-start-auto" class="btn-start-game" onclick="startAutoPlay()">CLICK TO START</button>
    </div>

    <div id="sidebar">
        <button onclick="location.href='index.html'" style="width:100%; background:#333; margin-bottom:10px; color:#aaa; font-size:11px;">ğŸ  GO TO SELECT</button>

        <h2>ğŸ¹ EDITOR v13.0</h2>
        <div class="control-group">
            <div class="group-title">1. Files</div>
            <label class="file-label" for="audioFile">ğŸµ Load Audio (MP3)</label>
            <input type="file" id="audioFile" accept="audio/*">
            <label class="file-label" for="mapJsonFile" style="margin-top:5px;">ğŸ“‚ Load Map (JSON)</label>
            <input type="file" id="mapJsonFile" accept=".json">
        </div>
        <div class="control-group">
            <div class="group-title">2. Map Settings</div>
            <div class="row">
                <input type="number" id="bpm" value="130" placeholder="BPM">
                <div style="display:flex; align-items:center; gap:2px; flex:1;">
                    <input type="number" id="beat-num" value="4" min="1" max="32" style="text-align:center;">
                    <span style="color:#888;">/</span>
                    <select id="beat-denom" style="text-align:center;">
                        <option value="4">4</option>
                        <option value="8">8</option>
                        <option value="2">2</option>
                        <option value="16">16</option>
                    </select>
                </div>
            </div>
            <div class="row" style="margin-top:5px;">
                <input type="number" id="offset" value="0" placeholder="Offset (ms)">
            </div>
        </div>
        <div class="control-group">
            <div class="group-title">3. Edit View</div>
            <div class="row"><span>Zoom:</span><input type="range" id="zoom" min="200" max="1000" step="50" value="400"></div>
            <div class="row"><span>Split:</span><input type="number" id="split" value="16" min="1" max="64" style="width: 60px; text-align: center;"></div>
            <button onclick="addMeasures(4)" style="width:100%; margin-top:5px;">+ Add 4 Bars</button>
        </div>
        <hr style="width:100%; border-color:#333; margin: 5px 0;">
        <div class="control-group">
            <button id="btn-record" style="background:#444; color:#aaa; border:1px solid #666; margin-bottom:5px;">ğŸ”´ RECORD: OFF</button>
            <button id="btn-play" class="primary">â–¶ EDIT PLAY (Space)</button>
            <button id="btn-stop">â¹ STOP</button>
        </div>
        <div class="control-group">
            <div class="group-title">4. Test Play</div>
            <div class="row"><span>Speed:</span><input type="range" id="test-speed" min="1" max="20" step="0.5" value="5.0"><span id="speed-val" class="val-label">x5.0</span></div>
            
            <label class="checkbox-label" style="margin-top:5px;">
                <input type="checkbox" id="chk-auto">
                <span style="font-size:12px; font-weight:bold; color:#d084ff;">ğŸ¤– Enable Auto Play</span>
            </label>

            <button id="btn-test" class="test-btn" style="margin-top:5px;">ğŸ® GAME START (Enter)</button>
        </div>
        
        <button id="btn-export" style="background:#28a745; color:white; margin-top:10px; margin-bottom:10px; padding:12px; border:none; flex-shrink: 0;">ğŸ’¾ EXPORT JSON</button>
    </div>
    <div id="editor-view">
        <div class="lane-header"><div>D</div><div>F</div><div>J</div><div>K</div></div>
        <div id="editor-container">
            <div id="canvas-layer">
                <div id="play-head"></div>
                <canvas id="gridCanvas" width="400" height="2400"></canvas>
            </div>
        </div>
    </div>
    <div id="game-view">
        <div id="game-canvas-container">
            <canvas id="gameCanvas" class="game"></canvas>
            <div id="game-hud">
                <div class="hud-item" style="text-align:left"><span class="hud-sub">RATE</span><br><span id="g-rate" class="hud-text">100%</span></div>
                <div class="hud-item" style="text-align:center"><span class="hud-sub">SCORE</span><br><span id="g-score" class="hud-text">000000</span></div>
                <div class="hud-item" style="text-align:right"><span class="hud-sub">COMBO</span><br><span id="g-combo" class="hud-text">0</span></div>
            </div>
            <div id="g-avg-box"><div id="g-avg">AVG: 0.0ms</div></div>
            <div id="auto-indicator">AUTO PLAY</div>
            <div id="result-overlay"></div>
        </div>

        <div id="test-controls">
            <div id="drag-handle" onmousedown="startDrag(event)"><span></span></div>
    
            <div class="ctrl-body">
                <input type="range" id="seek-bar" value="0" min="0" step="0.01" style="width:100%; margin-bottom: 8px;">
                
                <div class="ctrl-row" style="margin-bottom: 8px;">
                    <span id="time-display">00:00</span>
                    <div class="btn-group">
                        <button onclick="rewindTest()">â® RESET</button>
                        <button onclick="togglePauseTest()" id="btn-pause">â¸ PAUSE</button>
                    </div>
                </div>

                <div class="ctrl-row" style="border-top: 1px solid #444; padding-top: 8px;">
                    <span style="font-size:12px; color:#aaa; width:40px;">SPEED</span>
                    <input type="range" id="rate-slider" min="0.25" max="2.0" step="0.05" value="1.0" style="flex:1; margin: 0 10px;">
                    <span id="rate-val" style="font-size:12px; font-weight:bold; color:#00e5ff; width:35px; text-align:right;">1.0x</span>
                </div>
            </div>
        </div>
        <div id="test-msg">[ESC] Back to Editor</div>
    </div>
    <script>
        // ==========================================
        // 1. ê¸°ë³¸ ì„¤ì • ë° ì˜¤ë””ì˜¤ ì´ˆê¸°í™”
        // ==========================================
        const SERVER_URL = "https://port-0-vibecoding-rhythmgame-server-mkgu8rcq7cd54e6c.sel3.cloudtype.app/api/score"; 
        const GOOGLE_CLIENT_ID = "143854068141-s09m4p44lfju13dv2gdotoe9hbjfvmmr.apps.googleusercontent.com"; 
        const SFX_FIXED_TRIM = 0; 

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)({
            latencyHint: 'interactive', 
            sampleRate: 44100
        });
        const soundBuffers = {};

        function warmUpAudio() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            gain.gain.value = 0.001; 
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
        }

        async function loadSound(name, url) {
            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                soundBuffers[name] = audioBuffer;
            } catch (e) { console.warn(`Sound error: ${url}`); }
        }
        
        loadSound('hit', 'sfx/hit.mp3');
        loadSound('hold_start', 'sfx/hold_start.mp3');
        loadSound('hold_end', 'sfx/hold_end.mp3');
        loadSound('fc', 'sfx/full_combo.mp3');
        loadSound('ap', 'sfx/all_perfect.mp3');

        function playSfx(name, time = 0) {
            if (!soundBuffers[name]) return;
            const source = audioCtx.createBufferSource();
            source.buffer = soundBuffers[name];
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = 0.7;
            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const playTime = time > 0 ? time : audioCtx.currentTime;
            source.start(playTime, SFX_FIXED_TRIM); 
        }

        // ==========================================
        // 2. ì—ë””í„° ë³€ìˆ˜ ë° ë¡œì§
        // ==========================================
        let audio = new Audio();
        let bpm = 130, offset = 0;
        let beatNum = 4, beatDenom = 4;
        let measures = []; 
        let measureHeight = 400; 
        
        const BASE_RES = 192; 
        const LANE_COUNT = 4, CANVAS_WIDTH = 400, LANE_WIDTH = 100;
        
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const playHead = document.getElementById('play-head');
        const editorContainer = document.getElementById('editor-container');
        const splitInput = document.getElementById('split');
        const zoomSlider = document.getElementById('zoom');
        const speedSlider = document.getElementById('test-speed');
        const speedVal = document.getElementById('speed-val');
        const offsetInput = document.getElementById('offset');
        const bpmInput = document.getElementById('bpm');

        // ì´ˆê¸°í™”
        for(let i=0; i<50; i++) measures.push({index: i, notes: []});
        resizeEditor(); drawGrid();

        editorContainer.addEventListener('scroll', () => { requestAnimationFrame(drawGrid); });

        document.getElementById('beat-num').addEventListener('change', e => beatNum = parseInt(e.target.value) || 4);
        document.getElementById('beat-denom').addEventListener('change', e => beatDenom = parseInt(e.target.value) || 4);

        // ==========================================
        // 3. ê²Œì„ ë·° ë° í…ŒìŠ¤íŠ¸ ëª¨ë“œ ë³€ìˆ˜
        // ==========================================
        const gameView = document.getElementById('game-view');
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        const resultOverlay = document.getElementById('result-overlay');
        const autoIndicator = document.getElementById('auto-indicator'); 
        const recBtn = document.getElementById('btn-record');
        
        gameCanvas.width = 400;
        gameCanvas.height = window.innerHeight;
        const HIT_LINE_Y = window.innerHeight * 0.85; 
        const COLORS = ['#FF4081', '#00E676', '#00E676', '#448AFF'];
        
        // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
        let isGameTesting = false, gameFinished = false;
        let isAutoMode = false; 
        let gameNotes = [], activeNotes = [], particles = [], recentHits = [], judgments = [];
        let activeKeys = [false, false, false, false];
        let combo = 0, maxCombo = 0, totalHits = 0, totalRateSum = 0, totalOffsetDiff = 0, score = 0;
        let gameAnimId, noteSpeed = 5.0;
        let scorePerHit = 0; 
        let startTimestamp = 0;
        const START_DELAY = 2000; 
        let lastNoteEndTime = 0; 
        let totalMaxHits = 0;
        let judgeStats = { perfect: 0, great: 0, okay: 0, oh: 0, miss: 0 };
        let forceFinishTimer = null; 
        let isRecording = false; 

        // í…ŒìŠ¤íŠ¸ ì»¨íŠ¸ë¡¤ëŸ¬ ë³€ìˆ˜
        let isPaused = false;
        const seekBar = document.getElementById('seek-bar');
        const timeDisplay = document.getElementById('time-display');
        const pauseBtn = document.getElementById('btn-pause');

        // â–¼â–¼â–¼ [ì—¬ê¸° ì¶”ê°€í•˜ì„¸ìš”] â–¼â–¼â–¼
        const rateSlider = document.getElementById('rate-slider');
        const rateVal = document.getElementById('rate-val');

        // ë°°ì† ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸
        rateSlider.addEventListener('input', e => {
            const val = parseFloat(e.target.value);
            audio.playbackRate = val; // ì˜¤ë””ì˜¤ ì†ë„ ë³€ê²½
            rateVal.innerText = val.toFixed(2) + "x";
        });

        // URL íŒŒë¼ë¯¸í„° ì²˜ë¦¬
        const urlParams = new URLSearchParams(window.location.search);
        const songParam = urlParams.get('song');
        const diffParam = urlParams.get('diff');
        const speedParam = urlParams.get('speed');

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        if (songParam && diffParam) {
            document.getElementById('sidebar').style.display = 'none';
            document.getElementById('editor-view').style.display = 'none';
            document.getElementById('loading-screen').style.display = 'flex';
            loadGameData(songParam, diffParam);
        }

        async function loadGameData(song, diff) {
            const loadingMsg = document.getElementById('loading-msg');
            const startBtn = document.getElementById('btn-start-auto');
            try {
                loadingMsg.innerText = `LOADING CHART: ${diff}...`;
                const chartRes = await fetch(`Maps/${song}/${diff}.json`);
                if(!chartRes.ok) throw new Error("Chart not found");
                const chartData = await chartRes.json();
                parseChartData(chartData);

                loadingMsg.innerText = "LOADING AUDIO...";
                const audioRes = await fetch(`Maps/${song}/audio.mp3`);
                if(!audioRes.ok) throw new Error("Audio fetch failed");
                const audioBlob = await audioRes.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                
                audio.src = audioUrl;
                audio.load();
                
                audio.oncanplaythrough = () => { 
                    loadingMsg.style.display = 'none'; 
                    startBtn.style.display = 'block'; 
                };
                audio.onerror = () => { throw new Error("Audio decode error"); };

            } catch (err) {
                alert(`Error: ${err.message}\nPlease run with Live Server!`);
                window.location.href = "index.html"; 
            }
        }

        function parseChartData(data) {
            if(data.bpm) bpm = data.bpm;
            if(data.offset !== undefined) offset = data.offset; else offset = 0;
            if(data.beat) { beatNum = data.beat; document.getElementById('beat-num').value = beatNum; }
            if(data.beatDenom) { beatDenom = data.beatDenom; document.getElementById('beat-denom').value = beatDenom; } 
            else { beatDenom = 4; document.getElementById('beat-denom').value = 4; }

            measures = []; 
            if(data.measures) {
                const maxIdx = data.measures[data.measures.length-1].index;
                for(let i=0; i<=maxIdx + 5; i++) measures.push({index: i, notes: []});
                data.measures.forEach(m => {
                    const fileSplit = m.split || 32; 
                    const ratio = BASE_RES / fileSplit; 
                    if(measures[m.index]) {
                        measures[m.index].notes = m.notes.map(n => ({
                            lane: n.lane,
                            pos: Math.round(n.pos * ratio), 
                            len: Math.round((n.len || 0) * ratio) 
                        }));
                    }
                });
            }
        }

        function startAutoPlay() { 
            warmUpAudio(); 
            document.getElementById('loading-screen').style.display = 'none'; 
            startTestMode(false); 
        }

        let dragNote = null;
        let isDragging = false;
        let startY = 0;

        document.getElementById('audioFile').addEventListener('change', e => { if(e.target.files[0]) { audio.src = URL.createObjectURL(e.target.files[0]); document.querySelector('label[for="audioFile"]').innerText = "ğŸµ " + e.target.files[0].name; } });
        document.getElementById('mapJsonFile').addEventListener('change', e => {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    parseChartData(data);
                    resizeEditor(); drawGrid();
                    if(data.bpm) bpmInput.value = data.bpm;
                    if(data.offset) offsetInput.value = data.offset;
                    document.querySelector('label[for="mapJsonFile"]').innerText = "ğŸ“‚ " + file.name;
                    alert("ë¡œë“œ ì™„ë£Œ!");
                } catch(err) { alert("Load Error: " + err); }
            };
            reader.readAsText(file);
        });

        // ë…¹í™” ë²„íŠ¼
        recBtn.addEventListener('click', () => {
            isRecording = !isRecording;
            if(isRecording) {
                recBtn.innerText = "ğŸ”´ RECORD: ON";
                recBtn.style.background = "#ff0000"; recBtn.style.color = "#fff"; recBtn.style.boxShadow = "0 0 15px rgba(255,0,0,0.5)";
            } else {
                recBtn.innerText = "ğŸ”´ RECORD: OFF";
                recBtn.style.background = "#444"; recBtn.style.color = "#aaa"; recBtn.style.boxShadow = "none";
            }
        });

        document.getElementById('bpm').addEventListener('change', e => bpm = parseFloat(e.target.value));
        offsetInput.addEventListener('input', e => { offset = parseInt(e.target.value) || 0; if(!isEditPlaying && audio.currentTime > 0) updatePlayHeadPos(); });
        splitInput.addEventListener('input', drawGrid);
        zoomSlider.addEventListener('input', e => { measureHeight = parseInt(e.target.value); resizeEditor(); drawGrid(); if(!isEditPlaying && audio.currentTime > 0) updatePlayHeadPos(); });
        speedSlider.addEventListener('input', e => { noteSpeed = parseFloat(e.target.value); speedVal.innerText = "x" + noteSpeed.toFixed(1); });

        document.getElementById('btn-export').addEventListener('click', () => { 
            const data = { 
                title: "Custom Chart", 
                bpm, offset, beat: beatNum, beatDenom: beatDenom, 
                measures: measures.filter(m => m.notes.length > 0).map(m => ({ ...m, split: BASE_RES })) 
            }; 
            const a = document.createElement('a'); 
            a.href = URL.createObjectURL(new Blob([JSON.stringify(data)], {type:'application/json'})); 
            a.download = 'chart.json'; a.click(); 
        });

        // [ìˆ˜ì •] ë§ˆìš°ìŠ¤ í´ë¦­ ì¢Œí‘œ ê³„ì‚° (ìŠ¤í¬ë¡¤ ë³´ì •)
        gridCanvas.addEventListener('mousedown', e => {
            if(e.button !== 0) return;
            const rect = gridCanvas.getBoundingClientRect();
    
            // í´ë¦­í•œ í™”ë©´ ì¢Œí‘œ (Canvas ê¸°ì¤€)
            const clientY = e.clientY - rect.top;
    
            // â˜… ì‹¤ì œ ì°¨íŠ¸ìƒì˜ ì¢Œí‘œ = í™”ë©´ ì¢Œí‘œ + ìŠ¤í¬ë¡¤ ëœ ë§Œí¼ì˜ ê±°ë¦¬
            const absoluteY = clientY + editorContainer.scrollTop; 
    
            const x = e.clientX - rect.left;
            const lane = Math.floor(x / LANE_WIDTH);
    
            // ê³„ì‚°ëœ ì ˆëŒ€ Yê°’ìœ¼ë¡œ ë§ˆë”” ì¸ë±ìŠ¤ ì°¾ê¸°
            const measureIdx = Math.floor(absoluteY / measureHeight);
            if(measureIdx >= measures.length) return;

            const split = parseInt(splitInput.value) || 16;
            const relativeY = (absoluteY % measureHeight) / measureHeight; // ë§ˆë”” ë‚´ ë¹„ìœ¨
    
            const snapIdx = Math.round(relativeY * split);
            const pos192 = Math.round(snapIdx * (BASE_RES / split));
            if (pos192 >= BASE_RES) return; 

            const m = measures[measureIdx];
            const existingIdx = m.notes.findIndex(n => n.lane === lane && Math.abs(n.pos - pos192) < 2);

            if(existingIdx === -1) {
                const newNote = { lane, pos: pos192, len: 0 };
                m.notes.push(newNote); 
                dragNote = newNote; isDragging = true; 
                // ë“œë˜ê·¸ ì‹œì‘ì ë„ ì ˆëŒ€ ì¢Œí‘œë¡œ ì €ì¥í•´ì•¼ í•¨
                startY = absoluteY; 
                playSfx('hit'); 
            } else {
                dragNote = m.notes[existingIdx]; isDragging = true;
                // ê¸°ì¡´ ë…¸íŠ¸ì˜ ì ˆëŒ€ ìœ„ì¹˜ ê³„ì‚°
                startY = (measureIdx * measureHeight) + (dragNote.pos / BASE_RES) * measureHeight;
            }
            drawGrid();
        });

        // [ìˆ˜ì •] ë§ˆìš°ìŠ¤ ì´ë™ (ë¡±ë…¸íŠ¸ ê¸¸ì´ ì¡°ì ˆ)
        window.addEventListener('mousemove', e => {
            if(!isDragging || !dragNote) return;
            const rect = gridCanvas.getBoundingClientRect();
    
            // í˜„ì¬ ë§ˆìš°ìŠ¤ì˜ ì ˆëŒ€ Y ìœ„ì¹˜
            const currentAbsY = (e.clientY - rect.top) + editorContainer.scrollTop;
    
            const distPx = Math.max(0, currentAbsY - startY);
            dragNote.len = Math.round((distPx / measureHeight) * BASE_RES);
            drawGrid();
        });

        window.addEventListener('mouseup', () => { isDragging = false; dragNote = null; });

        // [ìˆ˜ì •] ìš°í´ë¦­ ì‚­ì œ
        gridCanvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            const rect = gridCanvas.getBoundingClientRect();
            const clientY = e.clientY - rect.top;
            const absoluteY = clientY + editorContainer.scrollTop; // ì ˆëŒ€ ì¢Œí‘œ ë³€í™˜

            const x = e.clientX - rect.left;
            const lane = Math.floor(x / LANE_WIDTH);
            const measureIdx = Math.floor(absoluteY / measureHeight);
    
            if(measureIdx >= measures.length) return;
    
            const m = measures[measureIdx];
            const split = parseInt(splitInput.value) || 16;
            const relativeY = (absoluteY % measureHeight) / measureHeight;
            const pos192 = Math.round(Math.round(relativeY * split) * (BASE_RES / split));
    
            const idx = m.notes.findIndex(n => n.lane === lane && Math.abs(n.pos - pos192) < 5);
    
            if(idx !== -1) m.notes.splice(idx, 1);
            drawGrid();
        });

        // [ìˆ˜ì •] ì—ë””í„° í¬ê¸° ì¡°ì • í•¨ìˆ˜
        function resizeEditor() {
            const totalHeight = measures.length * measureHeight;
            const layer = document.getElementById('canvas-layer');
    
            // 1. ìŠ¤í¬ë¡¤ ì˜ì—­(Layer)ì€ ì „ì²´ ê¸¸ì´ë§Œí¼ ëŠ˜ë¦¼ (ìŠ¤í¬ë¡¤ë°” ìƒì„±ìš©)
            layer.style.height = totalHeight + "px";
    
            // 2. ìº”ë²„ìŠ¤(ê·¸ë¦¼íŒ)ëŠ” í™”ë©´ ë³´ì´ëŠ” ë§Œí¼ë§Œ í¬ê¸° ì¡ê¸° (ë©”ëª¨ë¦¬ ì ˆì•½)
            // ì—¬ìœ ë¶„ìœ¼ë¡œ í™”ë©´ ë†’ì´ì˜ 2ë°° ì •ë„ ì¡ì•„ì£¼ë©´ ë¶€ë“œëŸ¬ì›€
            gridCanvas.height = window.innerHeight + measureHeight; 
            gridCanvas.width = 400;
        }

        function addMeasures(n) { const start = measures.length; for(let i=0; i<n; i++) measures.push({index: start+i, notes:[]}); resizeEditor(); drawGrid(); }

        let isEditPlaying = false;
        let editAnimId;

        document.getElementById('btn-play').addEventListener('click', toggleEditPlay);
        document.getElementById('btn-stop').addEventListener('click', stopEditPlay);

        function toggleEditPlay() {
            if (!audio.src && !songParam) return alert("ë¨¼ì € MP3 íŒŒì¼ì„ ë¶ˆëŸ¬ì™€ì£¼ì„¸ìš”.");
            if (isEditPlaying) { stopEditPlay(); } 
            else {
                warmUpAudio(); 
                offset = parseInt(offsetInput.value) || 0;
                audio.play().then(() => {
                    isEditPlaying = true;
                    playHead.style.display = 'block';
                    editLoop();
                }).catch(e => { console.error(e); alert("ì¬ìƒ ì˜¤ë¥˜: " + e.message); });
            }
        }

        function stopEditPlay() {
            audio.pause();
            audio.currentTime = 0;
            isEditPlaying = false;
            cancelAnimationFrame(editAnimId);
            playHead.style.display = 'none';
            playHead.style.transform = "translateY(0px)";
            editorContainer.scrollTop = 0;
        }

        function updatePlayHeadPos() {
            const currentMs = audio.currentTime * 1000;
            const chartMs = currentMs - offset;
            const msPerMeasure = (60 / bpm) * (4 / beatDenom) * beatNum * 1000;
            const y = Math.max(0, (chartMs / msPerMeasure) * measureHeight);
            playHead.style.transform = `translateY(${y}px)`;
            return y;
        }
        
        function editLoop() {
            if(!isEditPlaying) return;
            const y = updatePlayHeadPos();
            if(y > editorContainer.scrollTop + (window.innerHeight/2)) {
                editorContainer.scrollTop = y - (window.innerHeight/2);
            }
            editAnimId = requestAnimationFrame(editLoop);
        }

        // [ìˆ˜ì •] ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸° í•¨ìˆ˜ (ê°€ìƒ ë Œë”ë§ ì ìš©)
        function drawGrid() {
            // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
            gridCtx.fillStyle = "#000"; 
            gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

            const split = parseInt(splitInput.value) || 16;
            const cellH = measureHeight / split;
            const scrollY = editorContainer.scrollTop; // í˜„ì¬ ìŠ¤í¬ë¡¤ ìœ„ì¹˜
    
            // â˜… [í•µì‹¬] í˜„ì¬ í™”ë©´ì— ë³´ì´ëŠ” ë§ˆë””ë§Œ ê³„ì‚° (ìµœì í™”)
            // ìº”ë²„ìŠ¤ ì¢Œí‘œê³„ ë³´ì •ì„ ìœ„í•´ scrollYë¥¼ ëºŒ
            const startMeasureIdx = Math.max(0, Math.floor(scrollY / measureHeight));
            const endMeasureIdx = Math.min(measures.length - 1, Math.ceil((scrollY + gridCanvas.height) / measureHeight));

            for (let i = startMeasureIdx; i <= endMeasureIdx; i++) {
                const m = measures[i];
        
                // â˜… ë§ˆë””ì˜ ì‹¤ì œ Y ìœ„ì¹˜ì—ì„œ ìŠ¤í¬ë¡¤ë§Œí¼ ëº€ ìœ„ì¹˜ì— ê·¸ë¦¼ (Relative Drawing)
                const drawY = (i * measureHeight) - scrollY; 

                // 1. ê·¸ë¦¬ë“œ ì„  ê·¸ë¦¬ê¸°
                gridCtx.lineWidth = 1;
                for(let j=0; j<split; j++) {
                    const ly = drawY + j*cellH;
                    gridCtx.strokeStyle = (j===0) ? "#888" : (j%(split/4)===0 ? "#555" : "#222");
                    gridCtx.beginPath(); gridCtx.moveTo(0, ly); gridCtx.lineTo(400, ly); gridCtx.stroke();
                }
        
                // 2. ë§ˆë”” ë²ˆí˜¸
                gridCtx.fillStyle="#fff"; gridCtx.font="12px Arial"; 
                gridCtx.fillText(i+1, 5, drawY+15);

                // 3. ì„¸ë¡œì„ 
                gridCtx.strokeStyle="#444"; gridCtx.lineWidth=1;
                for(let k=1; k<4; k++) { 
                    gridCtx.beginPath(); gridCtx.moveTo(k*100, drawY); 
                    gridCtx.lineTo(k*100, drawY + measureHeight); gridCtx.stroke(); 
                }

                // 4. ë…¸íŠ¸ ê·¸ë¦¬ê¸°
                m.notes.forEach(n => {
                    // ë…¸íŠ¸ì˜ í™”ë©´ìƒ Y ì¢Œí‘œ
                    const ny = drawY + (n.pos / BASE_RES) * measureHeight;
                    const visualH = 10; 
            
                    // ë¡±ë…¸íŠ¸
                    if(n.len > 0) {
                        const tailY = ny + (n.len / BASE_RES) * measureHeight;
                        gridCtx.fillStyle = COLORS[n.lane];
                        gridCtx.globalAlpha = 0.5;
                        gridCtx.fillRect(n.lane*100+10, ny + visualH/2, 80, tailY - ny);
                        gridCtx.globalAlpha = 1.0;
                    }
                    // ì¼ë°˜ ë…¸íŠ¸
                    gridCtx.fillStyle = COLORS[n.lane]; 
                    gridCtx.fillRect(n.lane*100+1, ny, 98, visualH);
                });
            }
        }

        // ==========================================
        // 4. í…ŒìŠ¤íŠ¸ ëª¨ë“œ ì§„ì… ë° ë¡œì§
        // ==========================================
        
        document.getElementById('btn-test').addEventListener('click', () => {
            const isAuto = document.getElementById('chk-auto').checked;
            startTestMode(isAuto);
        });
        
        function startTestMode(auto) {
            if(!audio.src && !songParam) return alert("MP3 Missing!");
            if(!songParam) offset = parseInt(offsetInput.value) || 0;
            
            warmUpAudio(); 

            if(isNaN(bpm) || bpm <= 0) bpm = 130;

            const userGlobalOffset = parseInt(localStorage.getItem('wb_global_offset') || 0);
            offset += userGlobalOffset;

            if (speedParam) noteSpeed = parseFloat(speedParam);
            else noteSpeed = parseFloat(speedSlider.value);

            isAutoMode = auto;
            if(autoIndicator) autoIndicator.style.display = isAutoMode ? 'block' : 'none';

            // UI ì´ˆê¸°í™”
            document.getElementById('test-controls').style.display = 'flex';
            
            // â˜… [ìˆ˜ì •ë¨] ìŠ¬ë¼ì´ë” Maxê°’ ì„¤ì • (ê²Œì„ ì‹œì‘ ì‹œ 1íšŒë§Œ ì„¤ì •)
            // ì˜¤ë””ì˜¤ ê¸¸ì´ vs (ë§ˆì§€ë§‰ ë…¸íŠ¸ + 10ì´ˆ) ì¤‘ í° ê°’
            const playLimit = Math.max(audio.duration || 0, (lastNoteEndTime / 1000) + 10);
            seekBar.max = playLimit;
            seekBar.value = 0;

            // â–¼â–¼â–¼ [ì—¬ê¸° ì¶”ê°€í•˜ì„¸ìš”] ë°°ì† ì´ˆê¸°í™” â–¼â–¼â–¼
            audio.playbackRate = 1.0;
            rateSlider.value = 1.0;
            rateVal.innerText = "1.00x";
            // â–²â–²â–² [ì—¬ê¸°ê¹Œì§€ ì¶”ê°€] â–²â–²â–²

            isPaused = false;
            pauseBtn.innerText = "â¸ PAUSE";

            // ë…¸íŠ¸ ìƒì„±
            gameNotes = [];
            totalMaxHits = 0; 
            lastNoteEndTime = 0;
            judgeStats = { perfect: 0, great: 0, okay: 0, oh: 0, miss: 0 }; 

            const msPerMeasure = (60000 / bpm) * (4 / beatDenom) * beatNum;
            measures.forEach(m => {
                m.notes.forEach(n => {
                    const time = (m.index * msPerMeasure) + (n.pos / BASE_RES) * msPerMeasure;
                    const duration = (n.len / BASE_RES) * msPerMeasure;
                    const noteTime = time + offset; 
                    const noteEndTime = noteTime + duration;
                    if (noteEndTime > lastNoteEndTime) lastNoteEndTime = noteEndTime;

                    gameNotes.push({ 
                        time: noteTime, endTime: noteEndTime, lane: n.lane, len: n.len, 
                        hit: false, holding: false, finished: false, scheduled: false 
                    });
                    totalMaxHits++; 
                    if(n.len > 0) totalMaxHits++; 
                });
            });
            gameNotes.sort((a,b) => a.time - b.time);
            scorePerHit = totalMaxHits > 0 ? (1000000 / totalMaxHits) : 0;

            // ë…¸íŠ¸ ì¬ìƒì„± í›„ ìŠ¬ë¼ì´ë” ê¸¸ì´ ë‹¤ì‹œ í™•ì¸ (lastNoteEndTime ê°±ì‹ ë¨)
            const finalLimit = Math.max(audio.duration || 0, (lastNoteEndTime / 1000) + 10);
            seekBar.max = finalLimit;

            stopEditPlay();
            gameView.style.display = 'flex'; 
            resultOverlay.style.display = 'none';
            if(!songParam) document.getElementById('sidebar').style.display = 'none';
            
            activeNotes = []; particles = []; recentHits = []; judgments = []; activeKeys = [false,false,false,false];
            combo = 0; maxCombo = 0; totalHits = 0; totalRateSum = 0; totalOffsetDiff = 0; score = 0;
            updateGameHUD();
            
            isGameTesting = true; gameFinished = false;
            
            gameState = 'COUNTDOWN';
            startTimestamp = Date.now();
            gameStartTime = Date.now();
            audio.currentTime = 0;

            if (forceFinishTimer) clearTimeout(forceFinishTimer);

            gameLoop();
        }

        function stopTestMode() {
            isGameTesting = false; audio.pause(); audio.currentTime = 0;
            cancelAnimationFrame(gameAnimId);
            if (forceFinishTimer) clearTimeout(forceFinishTimer);
            if (songParam) window.location.href = "index.html"; 
            else { gameView.style.display = 'none'; document.getElementById('sidebar').style.display = 'flex'; }
        }

        function finishGame() {
            if (!isGameTesting || gameFinished) return;
            gameFinished = true;
            if (forceFinishTimer) clearTimeout(forceFinishTimer);
            audio.pause();
            setTimeout(showResult, 500);
        }

        // ==========================================
        // 5. ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (í‚¤ë³´ë“œ, ì‹œì»¤ë°”, ë“œë˜ê·¸)
        // ==========================================
        
        // ì‹œì»¤ë°”
        seekBar.addEventListener('input', (e) => {
            const time = parseFloat(e.target.value);
            
            // ì˜¤ë””ì˜¤ ë²”ìœ„ ì•ˆì´ë©´ ì´ë™, ë°–ì´ë©´ ëì— ë‘ 
            if (time <= audio.duration) {
                audio.currentTime = time;
            } else {
                audio.currentTime = audio.duration; 
            }
            
            const msTime = time * 1000;
            resetNoteStates(msTime);
            
            activeNotes = gameNotes.filter(n => {
                return (!n.finished || n.endTime > msTime) && (n.time - 2000 < msTime);
            });

            const m = Math.floor(time / 60).toString().padStart(2,'0');
            const s = Math.floor(time % 60).toString().padStart(2,'0');
            timeDisplay.innerText = `${m}:${s}`;

            if(isPaused) drawGameScreen(msTime);
        });

        function resetNoteStates(chartTime) {
            gameNotes.forEach(n => {
                if (n.endTime < chartTime) {
                    n.finished = true; n.hit = true; n.audioPlayed = true; n.holding = false;
                } else if (n.time > chartTime) {
                    n.finished = false; n.hit = false; n.holding = false; n.audioPlayed = false;
                } else if (n.len > 0 && n.time <= chartTime && n.endTime >= chartTime) {
                    n.finished = false; n.hit = false; n.holding = false; n.audioPlayed = true;
                } else {
                    n.finished = false; n.hit = false; n.audioPlayed = false;
                }
            });
            particles = []; judgments = []; activeKeys = [false, false, false, false];
        }

        function togglePauseTest() {
            if(gameFinished) return;
            isPaused = !isPaused;
            if(isPaused) { audio.pause(); pauseBtn.innerText = "â–¶ PLAY"; } 
            else { 
                // ì˜¤ë””ì˜¤ ë²”ìœ„ ì•ˆìª½ì´ë©´ ì¬ìƒ
                if (audio.currentTime < audio.duration) audio.play(); 
                pauseBtn.innerText = "â¸ PAUSE"; 
            }
        }

        function rewindTest() {
            audio.currentTime = 0;
            resetNoteStates(0);
            activeNotes = []; 
            combo = 0; score = 0; updateGameHUD();
            if(isPaused) {
                drawGameScreen(0);
                seekBar.value = 0;
                timeDisplay.innerText = "00:00";
            }
        }

        // í‚¤ë³´ë“œ ì…ë ¥
        const KEY_MAP = ['d', 'f', 'j', 'k'];
        window.addEventListener('keydown', e => {
            if(e.code === 'Space') { 
                e.preventDefault(); 
                if (isGameTesting) togglePauseTest();
                else if (!songParam) toggleEditPlay(); 
            }
            if(e.code === 'Enter' && !isGameTesting && !songParam) {
                const isAuto = document.getElementById('chk-auto').checked;
                startTestMode(isAuto);
            }
            if(e.code === 'Escape' && isGameTesting && !songParam) stopTestMode();
            
            const laneIdx = KEY_MAP.indexOf(e.key.toLowerCase());

            // [ê²Œì„ í”Œë ˆì´] ì…ë ¥ ì²˜ë¦¬
            if(isGameTesting && !gameFinished && !isAutoMode && !isPaused) {
                if(laneIdx !== -1 && !activeKeys[laneIdx]) { 
                    activeKeys[laneIdx] = true; 
                    checkHit(laneIdx); 
                }
            }

            // [ì—ë””í„° ë…¹í™”] ì…ë ¥ ì²˜ë¦¬
            if (isEditPlaying && isRecording && laneIdx !== -1) {
                const currentMs = audio.currentTime * 1000;
                const chartMs = currentMs - offset;
                const msPerMeasure = (60 / bpm) * (4 / beatDenom) * beatNum * 1000;
                const totalMeasurePos = chartMs / msPerMeasure;
                let mIdx = Math.floor(totalMeasurePos); 
                
                const split = parseInt(splitInput.value) || 16;
                const rawRatio = totalMeasurePos - mIdx; 
                const snappedRatio = Math.round(rawRatio * split) / split;
                let pos192 = Math.round(snappedRatio * BASE_RES);

                if (pos192 >= BASE_RES) { mIdx++; pos192 = 0; }

                if (measures[mIdx]) {
                    const exists = measures[mIdx].notes.some(n => n.lane === laneIdx && Math.abs(n.pos - pos192) < 2);
                    if (!exists) {
                        measures[mIdx].notes.push({ lane: laneIdx, pos: pos192, len: 0 });
                        playSfx('hit'); drawGrid();
                    }
                }
            }
        });

        window.addEventListener('keyup', e => {
            if(isGameTesting && !gameFinished && !isAutoMode && !isPaused) {
                const lane = KEY_MAP.indexOf(e.key.toLowerCase());
                if(lane !== -1) { activeKeys[lane] = false; checkRelease(lane); }
            }
        });

        // íŒì—… ë“œë˜ê·¸
        let isDraggingPopup = false;
        let dragOffsetX = 0, dragOffsetY = 0;
        const testPopup = document.getElementById('test-controls');

        function startDrag(e) {
            isDraggingPopup = true;
            const rect = testPopup.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            testPopup.style.transform = 'none';
            testPopup.style.left = rect.left + 'px';
            testPopup.style.top = rect.top + 'px';
            testPopup.style.bottom = 'auto'; 
        }

        window.addEventListener('mousemove', e => {
            if (!isDraggingPopup) return;
            testPopup.style.left = (e.clientX - dragOffsetX) + 'px';
            testPopup.style.top = (e.clientY - dragOffsetY) + 'px';
        });

        window.addEventListener('mouseup', () => { isDraggingPopup = false; });

        // ==========================================
        // 6. ê²Œì„ ë£¨í”„ ë° ê·¸ë¦¬ê¸°
        // ==========================================
        function drawGameScreen(currentTime) {
            gameCtx.fillStyle = '#000'; gameCtx.fillRect(0, 0, 400, gameCanvas.height);
            drawLaneBeams();
            drawJudgmentLine();

            const NOTE_SPEED_PX = 100 * noteSpeed; 
            let visibleNotes = gameNotes.filter(n => !n.finished && n.time - 2000 < currentTime);

            for(let i=0; i<visibleNotes.length; i++) {
                let n = visibleNotes[i];
                const headY = HIT_LINE_Y - ((n.time - currentTime) / 1000 * NOTE_SPEED_PX);
                let tailY = headY;
                if (n.len > 0) tailY = HIT_LINE_Y - ((n.endTime - currentTime) / 1000 * NOTE_SPEED_PX);

                if (tailY > gameCanvas.height || headY < -100) continue;

                if (n.len > 0) {
                    const drawHeadY = (n.hit && !isPaused) ? HIT_LINE_Y : headY; 
                    const clippedHeadY = Math.min(gameCanvas.height, drawHeadY);
                    const clippedTailY = Math.max(-100, tailY);
                    const bodyH = clippedHeadY - clippedTailY;
                    if (bodyH > 0 && clippedHeadY > -50) {
                        gameCtx.fillStyle = "rgba(255, 255, 255, 0.5)";
                        gameCtx.fillRect(n.lane * 100 + 10, clippedTailY, 80, bodyH);
                    }
                }
                if ((!n.hit || isPaused) && headY > -50 && headY < gameCanvas.height) {
                    gameCtx.fillStyle = COLORS[n.lane]; 
                    gameCtx.fillRect(n.lane * 100 + 5, headY - 12, 90, 24);
                    gameCtx.fillStyle = "rgba(255,255,255,0.7)"; 
                    gameCtx.fillRect(n.lane * 100 + 5, headY - 12, 90, 6);
                }
            }

            if(!isPaused) {
                drawParticles(); drawGameFX(); drawHitErrorBar();
            }
        }

        function gameLoop() {
            if(!isGameTesting || gameFinished) return;
            gameAnimId = requestAnimationFrame(gameLoop);
            
            if(isPaused) return; 

            const now = Date.now();
            let currentTime = -9999;

            if (gameState === 'COUNTDOWN') {
                currentTime = (now - startTimestamp) - START_DELAY; 
                if (now - startTimestamp >= START_DELAY) {
                    gameState = 'WAIT_AUDIO';
                    audio.play().catch(e => console.error("Play Fail", e));
                }
            } else if (gameState === 'WAIT_AUDIO' || gameState === 'PLAYING') {
                if (audio.currentTime > 0) gameState = 'PLAYING';
                
                // ì˜¤ë””ì˜¤ê°€ ë©ˆì·„ê±°ë‚˜ ëë‚¬ìœ¼ë©´ ì‹œì»¤ë°” ê°’(ê°€ìƒ ì‹œê°„) ì‚¬ìš©
                if (audio.ended || audio.paused) {
                    currentTime = parseFloat(seekBar.value) * 1000;
                } else {
                    currentTime = audio.currentTime * 1000;
                    // â˜… [ìˆ˜ì •] ì˜¤ë””ì˜¤ ì¬ìƒ ì¤‘ì—” ìŠ¬ë¼ì´ë” ì—…ë°ì´íŠ¸ (ë‹¨, Maxê°’ì€ ê±´ë“œë¦¬ì§€ ì•ŠìŒ!)
                    if(!isDraggingPopup && !isPaused) {
                        seekBar.value = audio.currentTime;
                        const m = Math.floor(audio.currentTime / 60).toString().padStart(2,'0');
                        const s = Math.floor(audio.currentTime % 60).toString().padStart(2,'0');
                        timeDisplay.innerText = `${m}:${s}`;
                    }
                }
            }

            // â˜… ì¢…ë£Œ ì¡°ê±´: ì˜¤ë””ì˜¤ ëë‚¨ + ì‹œì»¤ë°”ë„ ëê¹Œì§€ ê° (10ì´ˆ ì—¬ìœ ê¹Œì§€ í¬í•¨)
            if (currentTime > (lastNoteEndTime + 2000) && audio.ended && parseFloat(seekBar.value) >= seekBar.max) {
                 finishGame();
            }

            // ë…¸íŠ¸ ê°±ì‹  (ì‹±í¬ ë³´ì •)
            let pendingNotes = gameNotes.filter(n => !n.finished && n.time - 2000 < currentTime && !activeNotes.includes(n));
            activeNotes = activeNotes.concat(pendingNotes);

            if (isAutoMode) {
                activeNotes.forEach(n => {
                    if (!n.audioPlayed && currentTime >= n.time - 120) {
                        n.audioPlayed = true; 
                        if(n.len > 0) playSfx('hold_start');
                        else playSfx('hit');
                    }
                    if (!n.hit && currentTime >= n.time) {
                        n.hit = true; n.holding = true;
                        if(n.len === 0) n.finished = true;
                        activeKeys[n.lane] = true; 
                        createParticles(n.lane);
                        combo++; totalHits++; score += scorePerHit; totalRateSum += 100;
                        judgeStats.perfect++; 
                        updateGameHUD(); showJudge("PERFECT", n.lane, "#00e5ff");
                        if(n.len === 0) setTimeout(() => { if(!n.holding) activeKeys[n.lane] = false; }, 50);
                    }
                    if (n.hit && n.len > 0 && !n.finished) {
                        activeKeys[n.lane] = true;
                        if (currentTime >= n.endTime) {
                            n.finished = true;
                            activeKeys[n.lane] = false;
                            totalHits++; score += scorePerHit; totalRateSum += 100;
                            combo++; judgeStats.perfect++;
                            createParticles(n.lane); updateGameHUD(); playSfx('hold_end');
                        }
                    }
                });
            }

            // MISS ì²˜ë¦¬
            for(let i=0; i<activeNotes.length; i++) {
                let n = activeNotes[i];
                const NOTE_SPEED_PX = 100 * noteSpeed; 
                let tailY = HIT_LINE_Y - ((n.endTime - currentTime) / 1000 * NOTE_SPEED_PX);
                if (n.len === 0) tailY = HIT_LINE_Y - ((n.time - currentTime) / 1000 * NOTE_SPEED_PX);

                if (tailY > gameCanvas.height) {
                    if (!n.finished) {
                        n.finished = true;
                        if (!n.hit) { 
                            n.hit = true; combo = 0; totalHits++; judgeStats.miss++; 
                            if(n.len > 0) totalHits++; 
                            updateGameHUD(); showJudge("MISS", n.lane, "#ff5555");
                        }
                    }
                }
                
                if(!isAutoMode && !n.hit && !n.finished && currentTime > n.time + 250) { 
                    n.hit = true; n.finished = true; combo = 0; totalHits++; 
                    judgeStats.miss++; 
                    if(n.len > 0) totalHits++; 
                    updateGameHUD(); showJudge("MISS", n.lane, "#ff5555");
                    checkFinish();
                } 
                if (!isAutoMode && n.hit && n.len > 0 && !n.finished) {
                    if (activeKeys[n.lane]) {
                        if (currentTime >= n.endTime) {
                            n.finished = true; totalHits++; totalRateSum += 100; score += scorePerHit; 
                            combo++; judgeStats.perfect++; updateGameHUD(); createParticles(n.lane);
                            playSfx('hold_end'); checkFinish();
                        }
                    }
                }
            }
            activeNotes = activeNotes.filter(n => !n.finished);

            drawGameScreen(currentTime);
        }

        // ==========================================
        // 7. ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ (íŒì •, HUD, ì´í™íŠ¸)
        // ==========================================
        function checkFinish() { }

        function checkHit(lane) {
            let currentTime = 0;
            if (gameState === 'PLAYING' && audio.currentTime > 0) currentTime = audio.currentTime * 1000;
            else currentTime = (Date.now() - startTimestamp) - START_DELAY;

            const HIT_WINDOW = 150; 
            const candidates = activeNotes.filter(n => n.lane === lane && !n.hit && !n.finished && Math.abs(currentTime - n.time) <= HIT_WINDOW);
            if (candidates.length === 0) return;

            const n = candidates.reduce((prev, curr) => prev.time < curr.time ? prev : curr);
            const absDiff = Math.abs(currentTime - n.time);

            n.hit = true; n.holding = true; if (n.len === 0) n.finished = true;
            totalHits++; 
            if (n.len > 0) playSfx('hold_start'); else playSfx('hit');

            let judge="MISS", clr="#888", rate=0;
            if(absDiff <= 45) { judge="PERFECT"; clr="#00e5ff"; rate=100; judgeStats.perfect++; }
            else if(absDiff <= 90) { judge="GREAT"; clr="#00ff00"; rate=90; judgeStats.great++; }
            else if(absDiff <= 150) { judge="OKAY"; clr="#ffff00"; rate=50; judgeStats.okay++; }
            
            if(rate > 0) { combo++; if(combo > maxCombo) maxCombo = combo; score += (rate / 100) * scorePerHit; createParticles(lane); } 
            else { combo = 0; }
            
            totalRateSum += rate; updateGameHUD(); showJudge(judge, lane, clr); 
            recentHits.push({ diff: currentTime - n.time, color: clr, life: 600, maxLife: 600 });
            if(n.finished) checkFinish();
        }

        function checkRelease(lane) {
            const n = activeNotes.find(n => n.lane === lane && n.hit && !n.finished && n.len > 0);
            if (n) {
                let currentTime = 0;
                if (gameState === 'PLAYING' && audio.currentTime > 0) currentTime = audio.currentTime * 1000;
                else currentTime = (Date.now() - startTimestamp) - START_DELAY;

                const remaining = n.endTime - currentTime; 
                const safeZone = Math.max(300, (n.endTime - n.time) * 0.5); 
                
                if (remaining > safeZone) { 
                    n.finished = true; combo = 0; totalHits++; judgeStats.miss++; 
                    updateGameHUD(); showJudge("BREAK", lane, "#555");
                } else {
                    n.finished = true; totalHits++; score += scorePerHit; totalRateSum += 100; 
                    combo++; judgeStats.perfect++; 
                    createParticles(lane); updateGameHUD(); showJudge("PERFECT", lane, "#00e5ff");
                    playSfx('hold_end');
                }
                checkFinish();
            }
        }

        function updateGameHUD() {
            document.getElementById('g-combo').innerText = combo;
            document.getElementById('g-score').innerText = Math.round(score).toString().padStart(6, '0');
            const rate = totalHits > 0 ? (totalRateSum / (totalHits * 100)) * 100 : 100;
            document.getElementById('g-rate').innerText = rate.toFixed(2) + "%";
            const avg = totalHits > 0 ? (totalOffsetDiff/totalHits).toFixed(1) : "0.0";
            document.getElementById('g-avg').innerText = `AVG: ${avg}ms`;
        }
        function showJudge(text, lane, color) { judgments.push({text, x: lane*100+50, y: HIT_LINE_Y-100, life: 40, maxLife: 40, color}); }
        function drawGameFX() { for(let i=judgments.length-1; i>=0; i--) { const j = judgments[i]; gameCtx.save(); gameCtx.globalAlpha = j.life/j.maxLife; gameCtx.fillStyle = j.color; gameCtx.font="900 24px Arial"; gameCtx.textAlign="center"; gameCtx.fillText(j.text, j.x, j.y); gameCtx.restore(); j.life--; if(j.life<=0) judgments.splice(i,1); } }
        function drawHitErrorBar() { const cx = 200, cy = HIT_LINE_Y + 50, width = 300; gameCtx.fillStyle = "rgba(50, 50, 50, 0.8)"; gameCtx.fillRect(cx - width/2, cy - 2, width, 4); gameCtx.fillStyle = "#fff"; gameCtx.fillRect(cx - 1, cy - 8, 2, 16); for(let i = recentHits.length - 1; i >= 0; i--) { const h = recentHits[i]; const px = (h.diff / 100) * (width / 2); let drawX = Math.max(cx - width/2, Math.min(cx + width/2, cx + px)); gameCtx.fillStyle = h.color; gameCtx.globalAlpha = h.life / h.maxLife; gameCtx.fillRect(drawX - 1, cy - 6, 2, 12); gameCtx.globalAlpha = 1.0; h.life--; if(h.life <= 0) recentHits.splice(i, 1); } }
        function createParticles(lane) { for(let i=0; i<4; i++) particles.push({x:lane*100+50, y:HIT_LINE_Y, vx:(Math.random()-0.5)*10, vy:(Math.random()-1)*10-2, life:1, color:COLORS[lane]}); }
        function drawParticles() { for(let i=particles.length-1; i>=0; i--){ let p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.5; p.life-=0.05; if(p.life<=0) particles.splice(i,1); else { gameCtx.globalAlpha=p.life; gameCtx.fillStyle=p.color; gameCtx.fillRect(p.x,p.y,5,5); } } }
        function drawJudgmentLine() { gameCtx.shadowBlur = 0; gameCtx.lineWidth = 2; gameCtx.strokeStyle = '#00e5ff'; gameCtx.beginPath(); gameCtx.moveTo(0, HIT_LINE_Y); gameCtx.lineTo(400, HIT_LINE_Y); gameCtx.stroke(); gameCtx.strokeStyle = '#222'; gameCtx.lineWidth = 1; for(let i=0; i<=4; i++) { gameCtx.beginPath(); const x = i*100; gameCtx.moveTo(x, 0); gameCtx.lineTo(x, gameCanvas.height); gameCtx.stroke(); } }
        function drawLaneBeams() { gameCtx.globalCompositeOperation = 'source-over'; for(let i=0; i<4; i++) { if(activeKeys[i]) { const grd = gameCtx.createLinearGradient(0, HIT_LINE_Y, 0, HIT_LINE_Y - 300); grd.addColorStop(0, COLORS[i]); grd.addColorStop(1, "transparent"); gameCtx.fillStyle=grd; gameCtx.globalAlpha=0.2; gameCtx.fillRect(i*100,0,100,HIT_LINE_Y); } } gameCtx.globalCompositeOperation = 'source-over'; gameCtx.globalAlpha=1.0; }

        function showResult() {
            try {
                const rate = totalHits > 0 ? (totalRateSum / totalHits) : 0;
                let rank = "F"; 
                if(rate >= 95) rank = "S"; else if(rate >= 90) rank = "A"; else if(rate >= 80) rank = "B"; else if(rate >= 70) rank = "C";
                const finalScore = Math.round(score);
                const finalScoreStr = finalScore.toString().padStart(6, '0');
                
                if (songParam && diffParam) {
                    const storageKey = `wb_score_${songParam}_${diffParam}`;
                    const bestScore = parseInt(localStorage.getItem(storageKey) || "0");
                    if (finalScore > bestScore) localStorage.setItem(storageKey, finalScoreStr);
                }

                resultOverlay.innerHTML = `
                    <div style="text-align:center; margin-bottom:20px;"><h2 style="margin:0; color:#fff; font-size:32px; text-shadow:0 0 10px #00e5ff;">${songParam ? decodeURIComponent(songParam) : "CUSTOM PLAY"}</h2><div style="color:#aaa; font-size:16px; letter-spacing:2px; margin-top:5px;">${diffParam ? diffParam : "TEST MODE"}</div></div>
                    <div class="${rank} res-rank" style="font-size:140px; margin: 10px 0; line-height:1;">${rank}</div>
                    <div class="res-info" style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:20px; width:80%; max-width:600px; margin-bottom:30px;">
                        <div style="text-align:center"><div style="color:#888; font-size:14px; margin-bottom:5px;">SCORE</div><div style="font-size:28px; font-weight:bold;">${finalScoreStr}</div></div>
                        <div style="text-align:center"><div style="color:#888; font-size:14px; margin-bottom:5px;">RATE</div><div style="font-size:28px; font-weight:bold;">${rate.toFixed(2)}%</div></div>
                        <div style="text-align:center"><div style="color:#888; font-size:14px; margin-bottom:5px;">MAX COMBO</div><div style="font-size:28px; font-weight:bold;">${maxCombo}</div></div>
                    </div>
                    <div style="display:flex; justify-content:space-between; width:90%; max-width:600px; background:rgba(255,255,255,0.05); padding:20px; border-radius:15px; border:1px solid #333;">
                        <div style="text-align:center"><div style="color:#00e5ff; font-weight:bold; font-size:12px; margin-bottom:5px;">PERFECT</div><div style="color:#fff; font-size:20px;">${judgeStats.perfect}</div></div>
                        <div style="text-align:center"><div style="color:#00ff00; font-weight:bold; font-size:12px; margin-bottom:5px;">GREAT</div><div style="color:#fff; font-size:20px;">${judgeStats.great}</div></div>
                        <div style="text-align:center"><div style="color:#ffff00; font-weight:bold; font-size:12px; margin-bottom:5px;">OKAY</div><div style="color:#fff; font-size:20px;">${judgeStats.okay}</div></div>
                        <div style="text-align:center"><div style="color:#FF5252; font-weight:bold; font-size:12px; margin-bottom:5px;">OH...</div><div style="color:#fff; font-size:20px;">${judgeStats.oh}</div></div>
                        <div style="text-align:center"><div style="color:#ff0000; font-weight:bold; font-size:12px; margin-bottom:5px;">MISS</div><div style="color:#fff; font-size:20px;">${judgeStats.miss}</div></div>
                    </div>
                    <button class="btn-close" onclick="closeResult()" style="margin-top:40px;">CONTINUE</button>
                `;
                resultOverlay.style.display = 'flex';
            } catch(e) {
                alert("Result Error: " + e.message);
                location.href='index.html';
            }
        }

        function closeResult() { stopTestMode(); if(songParam) window.location.href="index.html"; }
        const ac = new (window.AudioContext||window.webkitAudioContext)();
        function playTick() { if(ac.state==='suspended') ac.resume(); const o = ac.createOscillator(); const g = ac.createGain(); o.connect(g); g.connect(ac.destination); o.frequency.value = 1200; g.gain.value = 0.1; o.start(); o.stop(ac.currentTime+0.05); }
    </script>
</body>
</html>