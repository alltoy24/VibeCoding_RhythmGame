<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>WEB BEAT : EDITOR (Ultimate V17)</title>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --accent: #00e5ff; --text: #eee; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; user-select: none; }
        
        #sidebar { 
            width: 320px; min-width: 320px; background: var(--panel); padding: 15px; 
            border-right: 1px solid #333; display: flex; flex-direction: column; gap: 12px; 
            z-index: 20; box-shadow: 2px 0 15px rgba(0,0,0,0.7); overflow-y: auto; max-height: 100vh;
        }
        #sidebar::-webkit-scrollbar { width: 8px; }
        #sidebar::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        
        h2 { margin: 0 0 10px 0; color: var(--accent); border-bottom: 2px solid var(--accent); padding-bottom: 5px; font-size: 20px; text-shadow: 0 0 10px rgba(0, 229, 255, 0.3); }
        .control-group { display: flex; flex-direction: column; gap: 6px; background: #2a2a2a; padding: 10px; border-radius: 6px; border: 1px solid #333; flex-shrink: 0; }
        .group-title { font-size: 11px; font-weight: bold; color: #aaa; text-transform: uppercase; margin-bottom: 4px; }
        
        input, select, button { padding: 6px; background: #111; border: 1px solid #444; color: #fff; border-radius: 4px; font-size: 11px; }
        input[type="range"] { padding: 0; cursor: pointer; accent-color: var(--accent); }
        button { cursor: pointer; font-weight: bold; transition: 0.2s; text-transform: uppercase; }
        button:hover { background: #444; filter: brightness(1.2); }
        button.primary { background: var(--accent); color: #000; border: none; box-shadow: 0 0 10px rgba(0, 229, 255, 0.2); }
        button.test-btn { background: #ff0055; color: white; border: none; font-size: 14px; padding: 12px; box-shadow: 0 0 15px rgba(255, 0, 85, 0.3); }
        
        .row { display: flex; gap: 5px; align-items: center; } .row > * { flex: 1; }
        .val-label { font-size: 12px; color: var(--accent); font-weight: bold; width: 40px; text-align: right; }
        .checkbox-label { display: flex; align-items: center; gap: 8px; cursor: pointer; background: #222; padding: 8px; border-radius: 4px; }
        input[type="file"] { display: none; }
        .file-label { display: block; padding: 8px; background: #333; text-align: center; border-radius: 4px; cursor: pointer; border: 1px dashed #666; font-size: 12px; }

        #editor-view { flex: 1; display: flex; flex-direction: column; position: relative; }
        #editor-container { flex: 1; overflow-y: scroll; background: #0a0a0a; display: flex; justify-content: center; position: relative; }
        #canvas-layer { position: relative; width: 400px; background: transparent; }
        #gridCanvas { position: sticky; top: 0; display: block; background: #000; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        #play-head { position: absolute; left: 0; width: 100%; height: 2px; background: #ff0055; z-index: 5; display: none; pointer-events: none; box-shadow: 0 0 10px #ff0055; will-change: transform; }
        .lane-header { display: flex; width: 400px; margin: 0 auto; background: #222; font-weight: bold; font-size: 12px; text-align: center; border-bottom: 2px solid #444; }
        .lane-header div { flex: 1; padding: 8px 0; border-right: 1px solid #333; color: #888; }

        #game-view { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 50; display: none; flex-direction: row; align-items: stretch; justify-content: center; }
        #game-canvas-container { position: relative; width: 400px; height: 100%; border-left: 2px solid #333; border-right: 2px solid #333; overflow: hidden; flex-shrink: 0; background: #000; }
        canvas.game { display: block; width: 100%; height: 100%; }
        
        #game-hud { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; pointer-events: none; z-index: 60; }
        .hud-item { flex: 1; }
        .hud-text { font-family: 'Impact', sans-serif; font-size: 32px; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); letter-spacing: 1px; }
        .hud-sub { font-size: 12px; color: #888; font-weight: bold; }
        #g-avg-box { position: absolute; bottom: 120px; width: 100%; text-align: center; pointer-events: none; }
        #g-avg { font-family: 'Consolas', monospace; font-size: 14px; font-weight: bold; color: #888; text-shadow: 0 0 2px #000; }
        #auto-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Impact'; font-size: 80px; color: rgba(123, 31, 162, 0.3); pointer-events: none; display: none; z-index: 55; }
        #finish-effect { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); width: 100%; text-align: center; pointer-events: none; z-index: 80; }

        .side-warn-col { flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; opacity: 0; transition: opacity 0.2s; background: transparent; }
        .chevron { width: 60px; height: 60px; border-top: 12px solid currentColor; border-right: 12px solid currentColor; transform: rotate(-45deg); margin: 20px 0; }
        .warn-up { opacity: 1; } .warn-up .chevron { color: #ff0055; filter: drop-shadow(0 0 20px #ff0055); animation: chevUp 0.3s infinite; } .warn-up .warn-label { color: #ff0055; text-shadow: 0 0 20px #ff0055; }
        .warn-down { opacity: 1; } .warn-down .chevron { color: #00e5ff; transform: rotate(135deg); filter: drop-shadow(0 0 20px #00e5ff); animation: chevDown 0.5s infinite; } .warn-down .warn-label { color: #00e5ff; text-shadow: 0 0 20px #00e5ff; }
        .warn-label { font-family: 'Impact', sans-serif; font-size: 40px; margin: 30px 0; letter-spacing: 4px; text-align: center; line-height: 1.2; }
        @keyframes chevUp { 0% { transform: translateY(30px) rotate(-45deg); opacity:0; } 50% { opacity:1; } 100% { transform: translateY(-30px) rotate(-45deg); opacity:0; } }
        @keyframes chevDown { 0% { transform: translateY(-30px) rotate(135deg); opacity:0; } 50% { opacity:1; } 100% { transform: translateY(30px) rotate(135deg); opacity:0; } }

        #test-controls { position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%); width: 400px; padding: 0; background: rgba(20, 20, 20, 0.95); border: 1px solid #444; border-radius: 8px; z-index: 200; display: none; flex-direction: column; box-shadow: 0 0 20px rgba(0,0,0,0.8); overflow: hidden; }
        #drag-handle { width: 100%; height: 25px; background: linear-gradient(90deg, #333, #444); cursor: grab; display: flex; justify-content: center; align-items: center; border-bottom: 1px solid #555; }
        #drag-handle span { width: 40px; height: 4px; background: #888; border-radius: 2px; }
        .ctrl-body { padding: 10px; display: flex; flex-direction: column; gap: 5px; }
        #test-controls input[type=range] { width: 100%; height: 5px; accent-color: #00e5ff; cursor: pointer; }
        .ctrl-row { display: flex; justify-content: space-between; align-items: center; }
        #time-display { font-family: 'Consolas', monospace; color: #fff; font-size: 14px; }
        .btn-group button { background: #333; border: 1px solid #555; color: #fff; padding: 5px 10px; cursor: pointer; font-size: 12px; border-radius: 4px; }
        #test-msg { position: absolute; bottom: 20px; color: #555; font-size: 12px; animation: blink 2s infinite; pointer-events: none;}
        @keyframes blink { 50% { opacity: 0.3; } }

        #result-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 300; display: none; flex-direction: column; align-items: center; justify-content: center; }
        .res-rank { font-family: 'Impact', sans-serif; font-size: 120px; color: #fff; text-shadow: 0 0 20px currentColor; margin-bottom: 20px; }
        .res-info { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px 40px; font-size: 24px; font-weight: bold; margin-bottom: 40px; }
        .btn-close { margin-top: 40px; padding: 15px 40px; font-size: 18px; background: #fff; color: #000; border: none; border-radius: 30px; cursor: pointer; font-weight: 900; }

        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 500; display: none; flex-direction: column; justify-content: center; align-items: center; color: #00e5ff; }
        .loading-text { font-family: 'Impact'; font-size: 40px; margin-bottom: 20px; animation: blink 1s infinite; }
        .btn-start-game { padding: 15px 50px; font-size: 24px; font-weight: bold; background: #ff0055; color: white; border: none; border-radius: 50px; cursor: pointer; display: none; }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-text" id="loading-msg">LOADING DATA...</div>
        <button id="btn-start-auto" class="btn-start-game" onclick="startAutoPlay()">CLICK TO START</button>
    </div>

    <div id="sidebar">
        <button onclick="location.href='index.html'" style="width:100%; background:#333; margin-bottom:10px; color:#aaa; font-size:11px;">üè† GO TO SELECT</button>

        <h2>üéπ EDITOR v17.0</h2>
        <div class="control-group">
            <div class="group-title">1. Files</div>
            <label class="file-label" for="audioFile">üéµ Load Audio (MP3)</label>
            <input type="file" id="audioFile" accept="audio/*">
            <label class="file-label" for="mapJsonFile" style="margin-top:5px;">üìÇ Load Map (JSON)</label>
            <input type="file" id="mapJsonFile" accept=".json">
        </div>
        <div class="control-group">
            <div class="group-title">2. Map Settings</div>
            <div class="row">
                <input type="number" id="bpm" value="130" placeholder="BPM">
                <div style="display:flex; align-items:center; gap:2px; flex:1;">
                    <input type="number" id="beat-num" value="4" min="1" max="32" style="text-align:center;">
                    <span style="color:#888;">/</span>
                    <select id="beat-denom" style="text-align:center;">
                        <option value="4">4</option>
                        <option value="8">8</option>
                        <option value="2">2</option>
                        <option value="16">16</option>
                    </select>
                </div>
            </div>
            <div class="row" style="margin-top:5px;">
                <input type="number" id="offset" value="0" placeholder="Offset (ms)">
            </div>
        </div>
        <div class="control-group">
            <div class="group-title">3. Edit View</div>
            <div class="row"><span>Zoom:</span><input type="range" id="zoom" min="200" max="1000" step="50" value="400"></div>
            <div class="row"><span>Split:</span><input type="number" id="split" value="16" min="1" max="64" style="width: 60px; text-align: center;"></div>
            <button onclick="addMeasures(4)" style="width:100%; margin-top:5px;">+ Add 4 Bars</button>
        </div>

        <div class="control-group" style="border-color: #ffd700;">
            <div class="group-title" style="color:#ffd700;">‚ö° Speed Trick</div>
            <div class="row">
                <span>Mult:</span>
                <input type="number" id="speed-mult-input" value="2.0" step="0.1" style="width:60px; text-align:center;">
                <span style="font-size:10px;">x</span>
            </div>
            <button id="btn-toggle-speed" onclick="toggleSpeedEditMode()" style="width:100%; margin-top:5px; background:#444; border:1px solid #ffd700; color:#ffd700;">
                OFF : NOTE MODE
            </button>
            <div style="font-size:10px; color:#888; margin-top:3px;">* Click Grid to Set Speed</div>
        </div>

        <hr style="width:100%; border-color:#333; margin: 5px 0;">
        <div class="control-group">
            <button id="btn-record" style="background:#444; color:#aaa; border:1px solid #666; margin-bottom:5px;">üî¥ RECORD: OFF</button>
            <button id="btn-play" class="primary">‚ñ∂ EDIT PLAY (Space)</button>
            <button id="btn-stop">‚èπ STOP</button>
        </div>
        <div class="control-group">
            <div class="group-title">4. Test Play</div>
            <div class="row"><span>Speed:</span><input type="range" id="test-speed" min="1" max="20" step="0.5" value="5.0"><span id="speed-val" class="val-label">x5.0</span></div>
            
            <label class="checkbox-label" style="margin-top:5px;">
                <input type="checkbox" id="chk-auto">
                <span style="font-size:12px; font-weight:bold; color:#d084ff;">ü§ñ Enable Auto Play</span>
            </label>

            <button id="btn-test" class="test-btn" style="margin-top:5px;">üéÆ GAME START (Enter)</button>
        </div>
        
        <button id="btn-export" style="background:#28a745; color:white; margin-top:10px; margin-bottom:10px; padding:12px; border:none; flex-shrink: 0;">üíæ EXPORT JSON</button>
    </div>
    
    <div id="editor-view">
        <div class="lane-header"><div>D</div><div>F</div><div>J</div><div>K</div></div>
        <div id="editor-container">
            <div id="canvas-layer">
                <div id="play-head"></div>
                <canvas id="gridCanvas" width="400" height="2400"></canvas>
            </div>
        </div>
    </div>
    
    <div id="game-view">
        <div id="warn-left" class="side-warn-col">
            <div class="chevron"></div><div class="chevron"></div><div class="chevron"></div>
            <div class="warn-label">SPEED<br>UP</div>
            <div class="chevron"></div><div class="chevron"></div><div class="chevron"></div>
        </div>

        <div id="game-canvas-container">
            <canvas id="gameCanvas" class="game"></canvas>
            <div id="finish-effect"></div>
            <div id="game-hud">
                <div class="hud-item" style="text-align:left"><span class="hud-sub">RATE</span><br><span id="g-rate" class="hud-text">100%</span></div>
                <div class="hud-item" style="text-align:center"><span class="hud-sub">SCORE</span><br><span id="g-score" class="hud-text">000000</span></div>
                <div class="hud-item" style="text-align:right"><span class="hud-sub">COMBO</span><br><span id="g-combo" class="hud-text">0</span></div>
            </div>
            <div id="g-avg-box"><div id="g-avg">AVG: 0.0ms</div></div>
            <div id="auto-indicator">AUTO PLAY</div>
            <div id="result-overlay"></div>
        </div>

        <div id="warn-right" class="side-warn-col">
            <div class="chevron"></div><div class="chevron"></div><div class="chevron"></div>
            <div class="warn-label">SPEED<br>UP</div>
            <div class="chevron"></div><div class="chevron"></div><div class="chevron"></div>
        </div>

        <div id="test-controls">
            <div id="drag-handle" onmousedown="startDrag(event)"><span></span></div>
            <div class="ctrl-body">
                <input type="range" id="seek-bar" value="0" min="0" step="0.01" style="width:100%; margin-bottom: 8px;">
                <div class="ctrl-row" style="margin-bottom: 8px;">
                    <span id="time-display">00:00</span>
                    <div class="btn-group">
                        <button onclick="rewindTest()">‚èÆ RESET</button>
                        <button onclick="togglePauseTest()" id="btn-pause">‚è∏ PAUSE</button>
                    </div>
                </div>
                <div class="ctrl-row" style="border-top: 1px solid #444; padding-top: 8px;">
                    <span style="font-size:12px; color:#aaa; width:40px;">SPEED</span>
                    <input type="range" id="rate-slider" min="0.25" max="2.0" step="0.05" value="1.0" style="flex:1; margin: 0 10px;">
                    <span id="rate-val" style="font-size:12px; font-weight:bold; color:#00e5ff; width:35px; text-align:right;">1.0x</span>
                </div>
            </div>
        </div>
        <div id="test-msg">[ESC] Back to Editor</div>
    </div>

    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive', sampleRate: 44100 });
        const soundBuffers = {};
        const SFX_FIXED_TRIM = 0; 

        function warmUpAudio() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const oscillator = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            gain.gain.value = 0.001; 
            oscillator.connect(gain);
            gain.connect(audioCtx.destination);
            oscillator.start();
        }

        async function loadSound(name, url) {
            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                soundBuffers[name] = audioBuffer;
            } catch (e) { console.warn(`Sound error: ${url}`); }
        }
        
        loadSound('hit', 'sfx/hit.mp3');
        loadSound('hold_start', 'sfx/hold_start.mp3');
        loadSound('hold_end', 'sfx/hold_end.mp3');
        loadSound('fc', 'sfx/full_combo.mp3');
        loadSound('ap', 'sfx/all_perfect.mp3');
        loadSound('glitch', 'sfx/glitch.mp3');

        function playSfx(name, time = 0) {
            if (!soundBuffers[name]) return;
            const source = audioCtx.createBufferSource();
            source.buffer = soundBuffers[name];
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = 0.7;
            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            source.start(time > 0 ? time : audioCtx.currentTime, SFX_FIXED_TRIM); 
        }

        let audio = new Audio();
        let bpm = 130, offset = 0;
        let beatNum = 4, beatDenom = 4;
        let measures = []; 
        let speedEvents = []; 
        let measureHeight = 400; 
        
        const BASE_RES = 192; 
        const LANE_COUNT = 4, CANVAS_WIDTH = 400, LANE_WIDTH = 100;
        
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const playHead = document.getElementById('play-head');
        const editorContainer = document.getElementById('editor-container');
        const splitInput = document.getElementById('split');
        const zoomSlider = document.getElementById('zoom');
        const speedSlider = document.getElementById('test-speed');
        const speedVal = document.getElementById('speed-val');
        const offsetInput = document.getElementById('offset');
        const bpmInput = document.getElementById('bpm');

        let isSpeedEditMode = false;
        const speedMultInput = document.getElementById('speed-mult-input');
        const btnToggleSpeed = document.getElementById('btn-toggle-speed');

        for(let i=0; i<50; i++) measures.push({index: i, notes: []});
        resizeEditor(); drawGrid();

        editorContainer.addEventListener('scroll', () => { requestAnimationFrame(drawGrid); });
        document.getElementById('beat-num').addEventListener('change', e => beatNum = parseInt(e.target.value) || 4);
        document.getElementById('beat-denom').addEventListener('change', e => beatDenom = parseInt(e.target.value) || 4);

        const gameView = document.getElementById('game-view');
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        const resultOverlay = document.getElementById('result-overlay');
        const autoIndicator = document.getElementById('auto-indicator'); 
        const recBtn = document.getElementById('btn-record');
        const finishEffect = document.getElementById('finish-effect');
        
        const warnLeft = document.getElementById('warn-left');
        const warnRight = document.getElementById('warn-right');

        gameCanvas.width = 400;
        gameCanvas.height = window.innerHeight;
        const HIT_LINE_Y = window.innerHeight * 0.85; 
        const COLORS = ['#FF4081', '#00E676', '#00E676', '#448AFF'];
        
        let isGameTesting = false, gameFinished = false;
        let isAutoMode = false; 
        let gameNotes = [], activeNotes = [], particles = [], recentHits = [], judgments = [];
        let activeKeys = [false, false, false, false];
        let combo = 0, maxCombo = 0, totalHits = 0, totalRateSum = 0, totalOffsetDiff = 0, score = 0;
        let gameAnimId, baseNoteSpeed = 5.0; 
        let currentNoteSpeed = 5.0;          
        let scorePerHit = 0; 
        let startTimestamp = 0;
        const START_DELAY = 2000; 
        let lastNoteEndTime = 0; 
        let totalMaxHits = 0;
        let judgeStats = { perfect: 0, great: 0, okay: 0, oh: 0, miss: 0 };
        let forceFinishTimer = null; 
        let isRecording = false; 

        let isPaused = false;
        const seekBar = document.getElementById('seek-bar');
        const timeDisplay = document.getElementById('time-display');
        const pauseBtn = document.getElementById('btn-pause');
        const rateSlider = document.getElementById('rate-slider');
        const rateVal = document.getElementById('rate-val');

        const urlParams = new URLSearchParams(window.location.search);
        const songParam = urlParams.get('song');
        const diffParam = urlParams.get('diff');
        const speedParam = urlParams.get('speed');

        if (songParam && diffParam) {
            document.getElementById('sidebar').style.display = 'none';
            document.getElementById('editor-view').style.display = 'none';
            document.getElementById('loading-screen').style.display = 'flex';
            loadGameData(songParam, diffParam);
        }

        function toggleSpeedEditMode() {
            isSpeedEditMode = !isSpeedEditMode;
            if(isSpeedEditMode) {
                btnToggleSpeed.innerText = "ON : SPEED MODE ‚ö°";
                btnToggleSpeed.style.background = "#ffd700";
                btnToggleSpeed.style.color = "#000";
            } else {
                btnToggleSpeed.innerText = "OFF : NOTE MODE";
                btnToggleSpeed.style.background = "#444";
                btnToggleSpeed.style.color = "#ffd700";
            }
        }

        async function loadGameData(song, diff) {
            const loadingMsg = document.getElementById('loading-msg');
            const startBtn = document.getElementById('btn-start-auto');
            try {
                loadingMsg.innerText = `LOADING CHART: ${diff}...`;
                const chartRes = await fetch(`Maps/${song}/${diff}.json`);
                if(!chartRes.ok) throw new Error("Chart not found");
                const chartData = await chartRes.json();
                parseChartData(chartData);

                loadingMsg.innerText = "LOADING AUDIO...";
                const audioRes = await fetch(`Maps/${song}/audio.mp3`);
                if(!audioRes.ok) throw new Error("Audio fetch failed");
                const audioBlob = await audioRes.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                audio.src = audioUrl;
                audio.load();
                audio.oncanplaythrough = () => { 
                    loadingMsg.style.display = 'none'; 
                    startBtn.style.display = 'block'; 
                };
            } catch (err) {
                alert(`Error: ${err.message}\nPlease run with Live Server!`);
                window.location.href = "index.html"; 
            }
        }

        function parseChartData(data) {
            if(data.bpm) bpm = data.bpm;
            if(data.offset !== undefined) offset = data.offset; else offset = 0;
            if(data.beat) { beatNum = data.beat; document.getElementById('beat-num').value = beatNum; }
            if(data.beatDenom) { beatDenom = data.beatDenom; document.getElementById('beat-denom').value = beatDenom; } 
            
            // ‚òÖ [FIX] Ï†ïÌôïÌïú Î∞ïÏûê Í≥ÑÏÇ∞
            const msPerMeasure = (60000 / bpm) * (4 / beatDenom) * beatNum;

            // ‚òÖ [FIX] Î∂àÎü¨Ïò® ÌååÏùºÏùò Î≥ÄÏÜç Ïù¥Î≤§Ìä∏Ïóê Ï¢åÌëúÍ∞Ä ÏóÜÏúºÎ©¥ Ïó≠ÏÇ∞
            if(data.speedEvents) {
                speedEvents = data.speedEvents.map(ev => {
                    if (ev.measureIdx === undefined) {
                        const mIdx = Math.floor(ev.time / msPerMeasure);
                        const p = ((ev.time % msPerMeasure) / msPerMeasure) * BASE_RES;
                        return { ...ev, measureIdx: mIdx, pos: Math.round(p) };
                    }
                    return ev;
                });
            } else speedEvents = [];

            measures = []; 
            if(data.measures) {
                const maxIdx = data.measures[data.measures.length-1].index;
                for(let i=0; i<=maxIdx + 5; i++) measures.push({index: i, notes: []});
                data.measures.forEach(m => {
                    const ratio = BASE_RES / (m.split || 32); 
                    if(measures[m.index]) {
                        measures[m.index].notes = m.notes.map(n => ({
                            lane: n.lane,
                            pos: Math.round(n.pos * ratio), 
                            len: Math.round((n.len || 0) * ratio) 
                        }));
                    }
                });
            }
        }

        function startAutoPlay() { 
            warmUpAudio(); 
            document.getElementById('loading-screen').style.display = 'none'; 
            startTestMode(false); 
        }

        let dragNote = null;
        let isDragging = false;
        let startY = 0;

        document.getElementById('audioFile').addEventListener('change', e => { if(e.target.files[0]) { audio.src = URL.createObjectURL(e.target.files[0]); document.querySelector('label[for="audioFile"]').innerText = "üéµ " + e.target.files[0].name; } });
        document.getElementById('mapJsonFile').addEventListener('change', e => {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    parseChartData(data);
                    resizeEditor(); drawGrid();
                    if(data.bpm) bpmInput.value = data.bpm;
                    if(data.offset) offsetInput.value = data.offset;
                    document.querySelector('label[for="mapJsonFile"]').innerText = "üìÇ " + file.name;
                    alert("Î°úÎìú ÏôÑÎ£å!");
                } catch(err) { alert("Load Error: " + err); }
            };
            reader.readAsText(file);
        });

        recBtn.addEventListener('click', () => {
            isRecording = !isRecording;
            if(isRecording) {
                recBtn.innerText = "üî¥ RECORD: ON";
                recBtn.style.background = "#ff0000"; recBtn.style.color = "#fff"; recBtn.style.boxShadow = "0 0 15px rgba(255,0,0,0.5)";
            } else {
                recBtn.innerText = "üî¥ RECORD: OFF";
                recBtn.style.background = "#444"; recBtn.style.color = "#aaa"; recBtn.style.boxShadow = "none";
            }
        });

        document.getElementById('bpm').addEventListener('change', e => bpm = parseFloat(e.target.value));
        offsetInput.addEventListener('input', e => { offset = parseInt(e.target.value) || 0; if(!isEditPlaying && audio.currentTime > 0) updatePlayHeadPos(); });
        splitInput.addEventListener('input', drawGrid);
        zoomSlider.addEventListener('input', e => { measureHeight = parseInt(e.target.value); resizeEditor(); drawGrid(); if(!isEditPlaying && audio.currentTime > 0) updatePlayHeadPos(); });
        speedSlider.addEventListener('input', e => { baseNoteSpeed = parseFloat(e.target.value); speedVal.innerText = "x" + baseNoteSpeed.toFixed(1); });

        document.getElementById('btn-export').addEventListener('click', () => { 
            // ‚òÖ [Ï§ëÏöî] ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïãú Î≥ÄÏÜç Ïù¥Î≤§Ìä∏Î•º Ï¢åÌëú Í∏∞Î∞òÏúºÎ°ú Ïû¨Í≥ÑÏÇ∞ÌïòÏó¨ Ï†ÄÏû•
            const msPerMeasure = (60000 / bpm) * (4 / beatDenom) * beatNum;
            const finalSpeedEvents = speedEvents.map(ev => ({
                time: Math.round((ev.measureIdx * msPerMeasure) + (ev.pos / BASE_RES) * msPerMeasure),
                mult: ev.mult,
                measureIdx: ev.measureIdx,
                pos: ev.pos
            }));

            const data = { 
                title: "Custom Chart", 
                bpm, offset, beat: beatNum, beatDenom: beatDenom, 
                speedEvents: finalSpeedEvents,
                measures: measures.filter(m => m.notes.length > 0).map(m => ({ ...m, split: BASE_RES })) 
            }; 
            const a = document.createElement('a'); 
            a.href = URL.createObjectURL(new Blob([JSON.stringify(data)], {type:'application/json'})); 
            a.download = 'chart.json'; a.click(); 
        });

        gridCanvas.addEventListener('mousedown', e => {
            if(e.button !== 0) return;
            const rect = gridCanvas.getBoundingClientRect();
            const clientY = e.clientY - rect.top;
            const absoluteY = clientY + editorContainer.scrollTop; 
            const x = e.clientX - rect.left;
            const lane = Math.floor(x / LANE_WIDTH);
            const measureIdx = Math.floor(absoluteY / measureHeight);
            
            if(measureIdx >= measures.length) {
                for(let i=measures.length; i<=measureIdx + 5; i++) measures.push({index:i, notes:[]});
                resizeEditor();
            }

            const split = parseInt(splitInput.value) || 16;
            const relativeY = (absoluteY % measureHeight) / measureHeight;
            const snapIdx = Math.round(relativeY * split);
            const pos192 = Math.round(snapIdx * (BASE_RES / split));
            if (pos192 >= BASE_RES) return; 

            if (isSpeedEditMode) {
                // ‚òÖ [FIX] Ï†ïÌôïÌïú ÏÇ≠Ï†ú ÌåêÏ†ï (Ïò§Ï∞® 10)
                const existIdx = speedEvents.findIndex(ev => ev.measureIdx === measureIdx && Math.abs(ev.pos - pos192) < 10);
                if(existIdx !== -1) {
                    speedEvents.splice(existIdx, 1);
                } else {
                    const mult = parseFloat(speedMultInput.value);
                    // Ï¢åÌëúÎßå Ï†ÄÏû•ÌïòÍ≥†, ÏãúÍ∞ÑÏùÄ startTestModeÏóêÏÑú Í≥ÑÏÇ∞
                    speedEvents.push({ time: 0, mult: mult, measureIdx: measureIdx, pos: pos192 });
                    speedEvents.sort((a,b) => (a.measureIdx - b.measureIdx) || (a.pos - b.pos)); 
                }
                drawGrid();
                return;
            }

            const m = measures[measureIdx];
            const existingIdx = m.notes.findIndex(n => n.lane === lane && Math.abs(n.pos - pos192) < 2);

            if(existingIdx === -1) {
                const newNote = { lane, pos: pos192, len: 0 };
                m.notes.push(newNote); dragNote = newNote; isDragging = true; startY = absoluteY; playSfx('hit'); 
            } else {
                dragNote = m.notes[existingIdx]; isDragging = true;
                startY = (measureIdx * measureHeight) + (dragNote.pos / BASE_RES) * measureHeight;
            }
            drawGrid();
        });

        window.addEventListener('mousemove', e => {
            if(!isDragging || !dragNote) return;
            const rect = gridCanvas.getBoundingClientRect();
            const currentAbsY = (e.clientY - rect.top) + editorContainer.scrollTop;
            const distPx = Math.max(0, currentAbsY - startY);
            dragNote.len = Math.round((distPx / measureHeight) * BASE_RES);
            drawGrid();
        });

        window.addEventListener('mouseup', () => { isDragging = false; dragNote = null; });

        gridCanvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            const rect = gridCanvas.getBoundingClientRect();
            const clientY = e.clientY - rect.top;
            const absoluteY = clientY + editorContainer.scrollTop;
            const x = e.clientX - rect.left;
            const lane = Math.floor(x / LANE_WIDTH);
            const measureIdx = Math.floor(absoluteY / measureHeight);
            if(measureIdx >= measures.length) return;
            
            const m = measures[measureIdx];
            const split = parseInt(splitInput.value) || 16;
            const relativeY = (absoluteY % measureHeight) / measureHeight;
            const pos192 = Math.round(Math.round(relativeY * split) * (BASE_RES / split));
            
            const idx = m.notes.findIndex(n => n.lane === lane && Math.abs(n.pos - pos192) < 5);
            if(idx !== -1) { m.notes.splice(idx, 1); drawGrid(); return; }
            
            if(isSpeedEditMode) {
                // ‚òÖ [FIX] Ïö∞ÌÅ¥Î¶≠ ÏÇ≠Ï†úÎèÑ Ï†ïÌôïÌïòÍ≤å
                const evIdx = speedEvents.findIndex(ev => ev.measureIdx === measureIdx && Math.abs(ev.pos - pos192) < 10);
                if(evIdx !== -1) speedEvents.splice(evIdx, 1);
            }
            drawGrid();
        });

        function resizeEditor() { 
            const totalHeight = measures.length * measureHeight;
            const layer = document.getElementById('canvas-layer');
            layer.style.height = totalHeight + "px";
            gridCanvas.height = window.innerHeight + measureHeight; 
            gridCanvas.width = 400;
        }
        function addMeasures(n) { const start = measures.length; for(let i=0; i<n; i++) measures.push({index: start+i, notes:[]}); resizeEditor(); drawGrid(); }

        document.getElementById('btn-play').addEventListener('click', toggleEditPlay);
        document.getElementById('btn-stop').addEventListener('click', stopEditPlay);

        function toggleEditPlay() {
            if (!audio.src && !songParam) return alert("Î®ºÏ†Ä MP3 ÌååÏùºÏùÑ Î∂àÎü¨ÏôÄÏ£ºÏÑ∏Ïöî.");
            if (isEditPlaying) { stopEditPlay(); } 
            else {
                warmUpAudio(); 
                offset = parseInt(offsetInput.value) || 0;
                audio.play().then(() => {
                    isEditPlaying = true;
                    playHead.style.display = 'block';
                    editLoop();
                }).catch(e => { console.error(e); alert("Ïû¨ÏÉù Ïò§Î•ò: " + e.message); });
            }
        }

        function stopEditPlay() {
            audio.pause();
            audio.currentTime = 0;
            isEditPlaying = false;
            cancelAnimationFrame(editAnimId);
            playHead.style.display = 'none';
            playHead.style.transform = "translateY(0px)";
            editorContainer.scrollTop = 0;
        }

        function updatePlayHeadPos() {
            const currentMs = audio.currentTime * 1000;
            const chartMs = currentMs - offset;
            const msPerMeasure = (60 / bpm) * (4 / beatDenom) * beatNum * 1000;
            const y = Math.max(0, (chartMs / msPerMeasure) * measureHeight);
            playHead.style.transform = `translateY(${y}px)`;
            return y;
        }
        
        function editLoop() {
            if(!isEditPlaying) return;
            const y = updatePlayHeadPos();
            if(y > editorContainer.scrollTop + (window.innerHeight/2)) {
                editorContainer.scrollTop = y - (window.innerHeight/2);
            }
            editAnimId = requestAnimationFrame(editLoop);
        }

        function drawGrid() {
            gridCtx.fillStyle = "#000"; 
            gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

            const split = parseInt(splitInput.value) || 16;
            const cellH = measureHeight / split;
            const scrollY = editorContainer.scrollTop;
            
            const startMeasureIdx = Math.max(0, Math.floor(scrollY / measureHeight));
            const endMeasureIdx = Math.min(measures.length - 1, Math.ceil((scrollY + gridCanvas.height) / measureHeight));

            for (let i = startMeasureIdx; i <= endMeasureIdx; i++) {
                const m = measures[i];
                const drawY = (i * measureHeight) - scrollY; 

                gridCtx.lineWidth = 1;
                for(let j=0; j<split; j++) {
                    const ly = drawY + j*cellH;
                    gridCtx.strokeStyle = (j===0) ? "#888" : (j%(split/4)===0 ? "#555" : "#222");
                    gridCtx.beginPath(); gridCtx.moveTo(0, ly); gridCtx.lineTo(400, ly); gridCtx.stroke();
                }
                
                gridCtx.fillStyle="#fff"; gridCtx.font="12px Arial"; gridCtx.fillText(i+1, 5, drawY+15);
                gridCtx.strokeStyle="#444"; gridCtx.lineWidth=1;
                for(let k=1; k<4; k++) { gridCtx.beginPath(); gridCtx.moveTo(k*100, drawY); gridCtx.lineTo(k*100, drawY + measureHeight); gridCtx.stroke(); }
            }

            const noteStartIdx = Math.max(0, startMeasureIdx - 20); 
            for (let i = noteStartIdx; i <= endMeasureIdx; i++) {
                const m = measures[i];
                const drawY = (i * measureHeight) - scrollY; 

                m.notes.forEach(n => {
                    const ny = drawY + (n.pos / BASE_RES) * measureHeight;
                    let tailY = ny;
                    const visualH = 10;
                    if(n.len > 0) tailY = ny + (n.len / BASE_RES) * measureHeight;
                    else tailY = ny + visualH;

                    if (tailY < 0 || ny > gridCanvas.height) return;

                    if(n.len > 0) {
                        gridCtx.fillStyle = COLORS[n.lane]; gridCtx.globalAlpha = 0.5;
                        gridCtx.fillRect(n.lane*100+10, ny + visualH/2, 80, tailY - ny);
                        gridCtx.globalAlpha = 1.0;
                    }
                    gridCtx.fillStyle = COLORS[n.lane]; 
                    gridCtx.fillRect(n.lane*100+1, ny, 98, visualH);
                });
            }

            speedEvents.forEach(ev => {
                let mIdx = ev.measureIdx;
                let pos = ev.pos;
                // ÏóêÎîîÌÑ∞ Í∑∏Î¶¨Í∏∞ÏóêÏÑúÎäî Ï†ÄÏû•Îêú Ï¢åÌëúÎ•º Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©
                if (mIdx >= startMeasureIdx && mIdx <= endMeasureIdx) {
                    const y = (mIdx * measureHeight) + (pos / BASE_RES) * measureHeight - scrollY;
                    gridCtx.strokeStyle = "#ffd700";
                    gridCtx.lineWidth = 3;
                    gridCtx.beginPath(); gridCtx.moveTo(0, y); gridCtx.lineTo(400, y); gridCtx.stroke();
                    gridCtx.fillStyle = "#ffd700";
                    gridCtx.font = "bold 14px Arial";
                    gridCtx.fillText(`‚ö° x${ev.mult}`, 10, y - 5);
                }
            });
        }

        document.getElementById('btn-test').addEventListener('click', () => {
            const isAuto = document.getElementById('chk-auto').checked;
            startTestMode(isAuto);
        });

        rateSlider.addEventListener('input', e => {
            const val = parseFloat(e.target.value);
            audio.playbackRate = val; 
            rateVal.innerText = val.toFixed(2) + "x";
        });

        // ‚òÖ [ÌïµÏã¨] Î≥ÄÏÜç Îßµ ÎπåÎìú
        let speedMap = [];
        function buildSpeedMap(events) {
            speedMap = [];
            const sortedEvents = [...events].sort((a,b) => a.time - b.time);
            
            speedMap.push({ time: -999999, vPos: 0, mult: 1.0 });

            sortedEvents.forEach(ev => {
                const prev = speedMap[speedMap.length-1];
                const dist = (ev.time - prev.time) * prev.mult;
                speedMap.push({
                    time: ev.time,
                    vPos: prev.vPos + dist,
                    mult: ev.mult,
                    warned: false 
                });
            });
        }

        function getVisualPos(time) {
            let ev = speedMap[0];
            for(let i=1; i<speedMap.length; i++) {
                if (speedMap[i].time > time) break;
                ev = speedMap[i];
            }
            return ev.vPos + (time - ev.time) * ev.mult;
        }
        
        function startTestMode(auto) {
            if(!audio.src && !songParam) return alert("MP3 Missing!");
            
            // ‚òÖ [FIX] Ïò§ÌîÑÏÖã Í≥ÑÏÇ∞ (Ï§ëÏ≤© Î∞©ÏßÄ)
            let playOffset = 0;
            if(!songParam) {
                playOffset = (parseInt(offsetInput.value) || 0) + parseInt(localStorage.getItem('wb_global_offset') || 0);
            } else {
                playOffset = offset + parseInt(localStorage.getItem('wb_global_offset') || 0);
            }
            
            warmUpAudio(); 

            if(isNaN(bpm) || bpm <= 0) bpm = 130;

            if (speedParam) baseNoteSpeed = parseFloat(speedParam);
            else baseNoteSpeed = parseFloat(speedSlider.value);

            isAutoMode = auto;
            if(autoIndicator) autoIndicator.style.display = isAutoMode ? 'block' : 'none';

            document.getElementById('test-controls').style.display = 'flex';
            audio.playbackRate = 1.0;
            rateSlider.value = 1.0;
            rateVal.innerText = "1.00x";

            gameNotes = [];
            totalMaxHits = 0; 
            lastNoteEndTime = 0;
            judgeStats = { perfect: 0, great: 0, okay: 0, oh: 0, miss: 0 }; 

            const msPerMeasure = (60000 / bpm) * (4 / beatDenom) * beatNum;
            measures.forEach(m => {
                m.notes.forEach(n => {
                    const time = (m.index * msPerMeasure) + (n.pos / BASE_RES) * msPerMeasure;
                    const duration = (n.len / BASE_RES) * msPerMeasure;
                    const noteTime = time + playOffset;
                    const noteEndTime = noteTime + duration;
                    if (noteEndTime > lastNoteEndTime) lastNoteEndTime = noteEndTime;

                    gameNotes.push({ 
                        time: noteTime, endTime: noteEndTime, lane: n.lane, len: n.len, 
                        hit: false, holding: false, finished: false, scheduled: false 
                    });
                    totalMaxHits++; 
                    if(n.len > 0) totalMaxHits++; 
                });
            });
            gameNotes.sort((a,b) => a.time - b.time);
            scorePerHit = totalMaxHits > 0 ? (1000000 / totalMaxHits) : 0;

            // ‚òÖ [FIX] Î≥ÄÏÜç Ïù¥Î≤§Ìä∏Î•º ÌòÑÏû¨ BPM Í∏∞Ï§ÄÏúºÎ°ú ÏÉàÎ°ú Í≥ÑÏÇ∞ÌïòÏó¨ Ïò§ÌîÑÏÖã Ï†ÅÏö©
            // (ÏóêÎîîÌÑ∞Ïóê Ï†ÄÏû•Îêú ÏòàÏ†Ñ ÏãúÍ∞ÑÏù¥ ÏïÑÎãàÎùº, ÌòÑÏû¨ Ï¢åÌëú Í∏∞Ï§Ä ÏãúÍ∞ÑÏúºÎ°ú ÎçÆÏñ¥ÏîÄ)
            const playSpeedEvents = speedEvents.map(ev => {
                const calculatedTime = (ev.measureIdx * msPerMeasure) + (ev.pos / BASE_RES) * msPerMeasure;
                return { ...ev, time: Math.round(calculatedTime + playOffset) };
            });
            buildSpeedMap(playSpeedEvents);

            const playLimit = Math.max(audio.duration || 0, (lastNoteEndTime / 1000) + 10);
            seekBar.max = playLimit;
            seekBar.value = 0;
            isPaused = false;
            pauseBtn.innerText = "‚è∏ PAUSE";

            warnLeft.className = 'side-warn-col';
            warnRight.className = 'side-warn-col';

            stopEditPlay();
            gameView.style.display = 'flex'; 
            resultOverlay.style.display = 'none';
            if(!songParam) document.getElementById('sidebar').style.display = 'none';
            
            activeNotes = []; particles = []; recentHits = []; judgments = []; activeKeys = [false,false,false,false];
            combo = 0; maxCombo = 0; totalHits = 0; totalRateSum = 0; totalOffsetDiff = 0; score = 0;
            updateGameHUD();
            
            isGameTesting = true; gameFinished = false;
            
            gameState = 'COUNTDOWN';
            startTimestamp = Date.now();
            gameStartTime = Date.now();
            audio.currentTime = 0;

            if (forceFinishTimer) clearTimeout(forceFinishTimer);

            gameLoop();
        }

        function stopTestMode() {
            isGameTesting = false; audio.pause(); audio.currentTime = 0;
            cancelAnimationFrame(gameAnimId);
            if (forceFinishTimer) clearTimeout(forceFinishTimer);
            if (songParam) window.location.href = "index.html"; 
            else { gameView.style.display = 'none'; document.getElementById('sidebar').style.display = 'flex'; }
        }

        function finishGame() {
            if (!isGameTesting || gameFinished) return;
            gameFinished = true;
            if (forceFinishTimer) clearTimeout(forceFinishTimer);
            audio.pause();
            setTimeout(showResult, 500);
        }

        seekBar.addEventListener('input', (e) => {
            const time = parseFloat(e.target.value);
            if (time <= audio.duration) audio.currentTime = time;
            else audio.currentTime = audio.duration; 
            
            const msTime = time * 1000;
            resetNoteStates(msTime);
            
            activeNotes = gameNotes.filter(n => {
                return (!n.finished || n.endTime > msTime) && (n.time - 2000 < msTime);
            });

            speedMap.forEach(ev => { ev.warned = (ev.time < msTime); });

            const m = Math.floor(time / 60).toString().padStart(2,'0');
            const s = Math.floor(time % 60).toString().padStart(2,'0');
            timeDisplay.innerText = `${m}:${s}`;

            if(isPaused) drawGameScreen(msTime);
        });

        function resetNoteStates(chartTime) {
            gameNotes.forEach(n => {
                if (n.endTime < chartTime) {
                    n.finished = true; n.hit = true; n.audioPlayed = true; n.holding = false;
                } else if (n.time > chartTime) {
                    n.finished = false; n.hit = false; n.holding = false; n.audioPlayed = false;
                } else if (n.len > 0 && n.time <= chartTime && n.endTime >= chartTime) {
                    n.finished = false; n.hit = false; n.holding = false; n.audioPlayed = true;
                } else {
                    n.finished = false; n.hit = false; n.audioPlayed = false;
                }
            });
            particles = []; judgments = []; activeKeys = [false, false, false, false];
        }

        function togglePauseTest() {
            if(gameFinished) return;
            isPaused = !isPaused;
            if(isPaused) { audio.pause(); pauseBtn.innerText = "‚ñ∂ PLAY"; } 
            else { 
                if (audio.currentTime < audio.duration) audio.play(); 
                pauseBtn.innerText = "‚è∏ PAUSE"; 
            }
        }

        function rewindTest() {
            audio.currentTime = 0;
            resetNoteStates(0);
            activeNotes = []; 
            currentNoteSpeed = baseNoteSpeed;
            
            combo = 0; score = 0; updateGameHUD();
            if(isPaused) {
                drawGameScreen(0);
                seekBar.value = 0;
                timeDisplay.innerText = "00:00";
            }
        }

        const KEY_MAP = ['d', 'f', 'j', 'k'];
        window.addEventListener('keydown', e => {
            if(e.code === 'Space') { 
                e.preventDefault(); 
                if (isGameTesting) togglePauseTest();
                else if (!songParam) toggleEditPlay(); 
            }
            if(e.code === 'Enter' && !isGameTesting && !songParam) {
                const isAuto = document.getElementById('chk-auto').checked;
                startTestMode(isAuto);
            }
            if(e.code === 'Escape' && isGameTesting && !songParam) stopTestMode();
            
            const laneIdx = KEY_MAP.indexOf(e.key.toLowerCase());

            if(isGameTesting && !gameFinished && !isAutoMode && !isPaused) {
                if(laneIdx !== -1 && !activeKeys[laneIdx]) { 
                    activeKeys[laneIdx] = true; 
                    checkHit(laneIdx); 
                }
            }

            if (isEditPlaying && isRecording && laneIdx !== -1) {
                const currentMs = audio.currentTime * 1000;
                const chartMs = currentMs - offset;
                const msPerMeasure = (60 / bpm) * (4 / beatDenom) * beatNum * 1000;
                const totalMeasurePos = chartMs / msPerMeasure;
                let mIdx = Math.floor(totalMeasurePos); 
                
                if(!measures[mIdx]) {
                    for(let i=measures.length; i<=mIdx + 5; i++) measures.push({index:i, notes:[]});
                    resizeEditor();
                }

                const split = parseInt(splitInput.value) || 16;
                const rawRatio = totalMeasurePos - mIdx; 
                const snappedRatio = Math.round(rawRatio * split) / split;
                let pos192 = Math.round(snappedRatio * BASE_RES);

                if (pos192 >= BASE_RES) { mIdx++; pos192 = 0; }

                if (measures[mIdx]) {
                    const exists = measures[mIdx].notes.some(n => n.lane === laneIdx && Math.abs(n.pos - pos192) < 2);
                    if (!exists) {
                        measures[mIdx].notes.push({ lane: laneIdx, pos: pos192, len: 0 });
                        playSfx('hit'); drawGrid();
                    }
                }
            }
        });

        window.addEventListener('keyup', e => {
            if(isGameTesting && !gameFinished && !isAutoMode && !isPaused) {
                const lane = KEY_MAP.indexOf(e.key.toLowerCase());
                if(lane !== -1) { activeKeys[lane] = false; checkRelease(lane); }
            }
        });

        let isDraggingPopup = false;
        let dragOffsetX = 0, dragOffsetY = 0;
        const testPopup = document.getElementById('test-controls');

        function startDrag(e) {
            isDraggingPopup = true;
            const rect = testPopup.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            testPopup.style.transform = 'none';
            testPopup.style.left = rect.left + 'px';
            testPopup.style.top = rect.top + 'px';
            testPopup.style.bottom = 'auto'; 
        }

        window.addEventListener('mousemove', e => {
            if (!isDraggingPopup) return;
            testPopup.style.left = (e.clientX - dragOffsetX) + 'px';
            testPopup.style.top = (e.clientY - dragOffsetY) + 'px';
        });

        window.addEventListener('mouseup', () => { isDraggingPopup = false; });

        function drawGameScreen(currentTime) {
            gameCtx.fillStyle = '#000'; gameCtx.fillRect(0, 0, 400, gameCanvas.height);
            drawLaneBeams();
            drawJudgmentLine();

            const currentVisualY = getVisualPos(currentTime);
            const GLOBAL_SCALE = 0.1 * baseNoteSpeed; 

            let visibleNotes = gameNotes.filter(n => !n.finished && n.endTime > currentTime - 1000 && n.time < currentTime + 5000);

            for(let i=0; i<visibleNotes.length; i++) {
                let n = visibleNotes[i];
                
                const nPos = getVisualPos(n.time);
                const endPos = (n.len > 0) ? getVisualPos(n.endTime) : nPos;

                const headY = HIT_LINE_Y - (nPos - currentVisualY) * GLOBAL_SCALE;
                let tailY = headY;
                
                if (n.len > 0) {
                    tailY = HIT_LINE_Y - (endPos - currentVisualY) * GLOBAL_SCALE;
                }

                if (tailY > gameCanvas.height || headY < -100) continue;

                if (n.len > 0) {
                    const drawHeadY = (n.hit && !isPaused) ? HIT_LINE_Y : headY; 
                    const clippedHeadY = Math.min(gameCanvas.height, drawHeadY);
                    const clippedTailY = Math.max(-100, tailY);
                    const bodyH = clippedHeadY - clippedTailY;
                    if (bodyH > 0) {
                        gameCtx.fillStyle = "rgba(255, 255, 255, 0.5)";
                        gameCtx.fillRect(n.lane * 100 + 10, clippedTailY, 80, bodyH);
                    }
                }
                if ((!n.hit || isPaused) && headY > -50) {
                    gameCtx.fillStyle = COLORS[n.lane]; 
                    gameCtx.fillRect(n.lane * 100 + 5, headY - 12, 90, 24);
                    gameCtx.fillStyle = "rgba(255,255,255,0.7)"; 
                    gameCtx.fillRect(n.lane * 100 + 5, headY - 12, 90, 6);
                }
            }

            speedMap.forEach(ev => {
                if(ev.time > currentTime && ev.time < currentTime + 5000) {
                    const evY = HIT_LINE_Y - (ev.vPos - currentVisualY) * GLOBAL_SCALE;
                    if(evY > 0 && evY < gameCanvas.height) {
                        gridCtx.strokeStyle = "#ffd700";
                        gridCtx.lineWidth = 3;
                        gridCtx.beginPath(); gridCtx.moveTo(0, evY); gridCtx.lineTo(400, evY); gridCtx.stroke();
                        gridCtx.fillStyle = "#ffd700";
                        gridCtx.font = "bold 14px Arial";
                        gridCtx.fillText(`x${ev.mult}`, 10, evY - 5);
                    }
                }
            });

            if(!isPaused) {
                drawParticles(); drawGameFX(); drawHitErrorBar();
            }
        }

        function gameLoop() {
            if(!isGameTesting || gameFinished) return;
            gameAnimId = requestAnimationFrame(gameLoop);
            
            if(isPaused) return; 

            const now = Date.now();
            let currentTime = -9999;

            if (gameState === 'COUNTDOWN') {
                currentTime = (now - startTimestamp) - START_DELAY; 
                if (now - startTimestamp >= START_DELAY) {
                    gameState = 'WAIT_AUDIO';
                    audio.play().catch(e => console.error("Play Fail", e));
                }
            } else if (gameState === 'WAIT_AUDIO' || gameState === 'PLAYING') {
                if (audio.currentTime > 0) gameState = 'PLAYING';
                if (audio.ended || audio.paused) {
                    currentTime = parseFloat(seekBar.value) * 1000;
                } else {
                    currentTime = audio.currentTime * 1000;
                    if(!isDraggingPopup && !isPaused) {
                        seekBar.value = audio.currentTime;
                        const m = Math.floor(audio.currentTime / 60).toString().padStart(2,'0');
                        const s = Math.floor(audio.currentTime % 60).toString().padStart(2,'0');
                        timeDisplay.innerText = `${m}:${s}`;
                    }
                }
            }

            if (currentTime > (lastNoteEndTime + 2000) && audio.ended && parseFloat(seekBar.value) >= seekBar.max) {
                 finishGame();
            }

            const msPerMeasure = (60000 / bpm) * (4 / beatDenom) * beatNum;
            let nextEvent = speedMap.find(ev => ev.time > currentTime);
            if (nextEvent && !nextEvent.warned) {
                let currentMult = 1.0;
                for(let i=0; i<speedMap.length; i++) {
                    if(speedMap[i].time <= currentTime) currentMult = speedMap[i].mult;
                    else break;
                }
                if (nextEvent.time - currentTime <= msPerMeasure) {
                    nextEvent.warned = true;
                    showSpeedWarning(nextEvent.mult, currentMult);
                }
            }

            let pendingNotes = gameNotes.filter(n => !n.finished && n.time - 2000 < currentTime && !activeNotes.includes(n));
            activeNotes = activeNotes.concat(pendingNotes);

            if (isAutoMode) {
                activeNotes.forEach(n => {
                    if (!n.audioPlayed && currentTime >= n.time - 120) {
                        n.audioPlayed = true; 
                        if(n.len > 0) playSfx('hold_start'); else playSfx('hit');
                    }
                    if (!n.hit && currentTime >= n.time) {
                        n.hit = true; n.holding = true;
                        if(n.len === 0) n.finished = true;
                        activeKeys[n.lane] = true; 
                        createParticles(n.lane);
                        combo++; totalHits++; score += scorePerHit; totalRateSum += 100;
                        judgeStats.perfect++; 
                        updateGameHUD(); showJudge("PERFECT", n.lane, "#00e5ff");
                        if(n.len === 0) setTimeout(() => { if(!n.holding) activeKeys[n.lane] = false; }, 50);
                    }
                    if (n.hit && n.len > 0 && !n.finished) {
                        activeKeys[n.lane] = true;
                        if (currentTime >= n.endTime) {
                            n.finished = true; activeKeys[n.lane] = false;
                            totalHits++; score += scorePerHit; totalRateSum += 100;
                            combo++; judgeStats.perfect++;
                            createParticles(n.lane); updateGameHUD(); playSfx('hold_end');
                        }
                    }
                });
            }

            for(let i=0; i<activeNotes.length; i++) {
                let n = activeNotes[i];
                const nPos = getVisualPos(n.time);
                const endPos = (n.len > 0) ? getVisualPos(n.endTime) : nPos;
                const currentVisualY = getVisualPos(currentTime);
                const GLOBAL_SCALE = 0.1 * baseNoteSpeed;
                
                let tailY = HIT_LINE_Y - (endPos - currentVisualY) * GLOBAL_SCALE;
                if (n.len === 0) tailY = HIT_LINE_Y - (nPos - currentVisualY) * GLOBAL_SCALE;

                if (tailY > gameCanvas.height) {
                    if (!n.finished) {
                        n.finished = true;
                        if (!n.hit) { 
                            n.hit = true; combo = 0; totalHits++; judgeStats.miss++; 
                            if(n.len > 0) totalHits++; 
                            updateGameHUD(); showJudge("MISS", n.lane, "#ff5555");
                        }
                    }
                }
                
                if(!isAutoMode && !n.hit && !n.finished && currentTime > n.time + 250) { 
                    n.hit = true; n.finished = true; combo = 0; totalHits++; 
                    judgeStats.miss++; 
                    if(n.len > 0) totalHits++; 
                    updateGameHUD(); showJudge("MISS", n.lane, "#ff5555");
                    checkFinish();
                } 
                if (!isAutoMode && n.hit && n.len > 0 && !n.finished) {
                    if (activeKeys[n.lane]) {
                        if (currentTime >= n.endTime) {
                            n.finished = true; totalHits++; totalRateSum += 100; score += scorePerHit; 
                            combo++; judgeStats.perfect++; updateGameHUD(); createParticles(n.lane);
                            playSfx('hold_end'); checkFinish();
                        }
                    }
                }
            }
            activeNotes = activeNotes.filter(n => !n.finished);

            drawGameScreen(currentTime);
        }

        function showSpeedWarning(targetMult, currentMult) {
            const left = document.getElementById('warn-left');
            const right = document.getElementById('warn-right');
            
            left.className = 'side-warn-col';
            right.className = 'side-warn-col';

            const isUp = targetMult > currentMult;
            const cls = isUp ? 'warn-up' : 'warn-down';
            const label = isUp ? "SPEED<br>UP" : "SLOW<br>DOWN";

            const leftLabel = left.querySelector('.warn-label');
            const rightLabel = right.querySelector('.warn-label');
            
            if(leftLabel) leftLabel.innerHTML = label;
            if(rightLabel) rightLabel.innerHTML = label;

            requestAnimationFrame(() => {
                left.classList.add(cls);
                right.classList.add(cls);
            });

            setTimeout(() => {
                left.className = 'side-warn-col';
                right.className = 'side-warn-col';
            }, 1500);
        }

        function checkFinish() { }

        function checkHit(lane) {
            let currentTime = 0;
            if (gameState === 'PLAYING' && audio.currentTime > 0) currentTime = audio.currentTime * 1000;
            else currentTime = (Date.now() - startTimestamp) - START_DELAY;

            const HIT_WINDOW = 150; 
            const candidates = activeNotes.filter(n => n.lane === lane && !n.hit && !n.finished && Math.abs(currentTime - n.time) <= HIT_WINDOW);
            if (candidates.length === 0) return;

            const n = candidates.reduce((prev, curr) => Math.abs(currentTime - curr.time) < Math.abs(currentTime - prev.time) ? curr : prev);
            const absDiff = Math.abs(currentTime - n.time);

            n.hit = true; n.holding = true; if (n.len === 0) n.finished = true;
            totalHits++; 
            if (n.len > 0) playSfx('hold_start'); else playSfx('hit');

            let judge="MISS", clr="#888", rate=0;
            if(absDiff <= 45) { judge="PERFECT"; clr="#00e5ff"; rate=100; judgeStats.perfect++; }
            else if(absDiff <= 90) { judge="GREAT"; clr="#00ff00"; rate=90; judgeStats.great++; }
            else if(absDiff <= 150) { judge="OKAY"; clr="#ffff00"; rate=50; judgeStats.okay++; }
            
            if(rate > 0) { combo++; if(combo > maxCombo) maxCombo = combo; score += (rate / 100) * scorePerHit; createParticles(lane); } 
            else { combo = 0; }
            
            totalRateSum += rate; updateGameHUD(); showJudge(judge, lane, clr); 
            recentHits.push({ diff: currentTime - n.time, color: clr, life: 600, maxLife: 600 });
            if(n.finished) checkFinish();
        }

        function checkRelease(lane) {
            const n = activeNotes.find(n => n.lane === lane && n.hit && !n.finished && n.len > 0);
            if (n) {
                let currentTime = 0;
                if (gameState === 'PLAYING' && audio.currentTime > 0) currentTime = audio.currentTime * 1000;
                else currentTime = (Date.now() - startTimestamp) - START_DELAY;

                const remaining = n.endTime - currentTime; 
                const safeZone = Math.max(300, (n.endTime - n.time) * 0.5); 
                
                if (remaining > safeZone) { 
                    n.finished = true; combo = 0; totalHits++; judgeStats.miss++; 
                    updateGameHUD(); showJudge("BREAK", lane, "#555");
                } else {
                    n.finished = true; totalHits++; score += scorePerHit; totalRateSum += 100; 
                    combo++; judgeStats.perfect++; 
                    createParticles(lane); updateGameHUD(); showJudge("PERFECT", lane, "#00e5ff");
                    playSfx('hold_end');
                }
                checkFinish();
            }
        }

        function updateGameHUD() {
            document.getElementById('g-combo').innerText = combo;
            document.getElementById('g-score').innerText = Math.round(score).toString().padStart(6, '0');
            const rate = totalHits > 0 ? (totalRateSum / (totalHits * 100)) * 100 : 100;
            document.getElementById('g-rate').innerText = rate.toFixed(2) + "%";
            const avg = totalHits > 0 ? (totalOffsetDiff/totalHits).toFixed(1) : "0.0";
            document.getElementById('g-avg').innerText = `AVG: ${avg}ms`;
        }
        function showJudge(text, lane, color) { judgments.push({text, x: lane*100+50, y: HIT_LINE_Y-100, life: 40, maxLife: 40, color}); }
        function drawGameFX() { for(let i=judgments.length-1; i>=0; i--) { const j = judgments[i]; gameCtx.save(); gameCtx.globalAlpha = j.life/j.maxLife; gameCtx.fillStyle = j.color; gameCtx.font="900 24px Arial"; gameCtx.textAlign="center"; gameCtx.fillText(j.text, j.x, j.y); gameCtx.restore(); j.life--; if(j.life<=0) judgments.splice(i,1); } }
        function drawHitErrorBar() { const cx = 200, cy = HIT_LINE_Y + 50, width = 300; gameCtx.fillStyle = "rgba(50, 50, 50, 0.8)"; gameCtx.fillRect(cx - width/2, cy - 2, width, 4); gameCtx.fillStyle = "#fff"; gameCtx.fillRect(cx - 1, cy - 8, 2, 16); for(let i = recentHits.length - 1; i >= 0; i--) { const h = recentHits[i]; const px = (h.diff / 100) * (width / 2); let drawX = Math.max(cx - width/2, Math.min(cx + width/2, cx + px)); gameCtx.fillStyle = h.color; gameCtx.globalAlpha = h.life / h.maxLife; gameCtx.fillRect(drawX - 1, cy - 6, 2, 12); gameCtx.globalAlpha = 1.0; h.life--; if(h.life <= 0) recentHits.splice(i, 1); } }
        function createParticles(lane) { for(let i=0; i<4; i++) particles.push({x:lane*100+50, y:HIT_LINE_Y, vx:(Math.random()-0.5)*10, vy:(Math.random()-1)*10-2, life:1, color:COLORS[lane]}); }
        function drawParticles() { for(let i=particles.length-1; i>=0; i--){ let p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.5; p.life-=0.05; if(p.life<=0) particles.splice(i,1); else { gameCtx.globalAlpha=p.life; gameCtx.fillStyle=p.color; gameCtx.fillRect(p.x,p.y,5,5); } } }
        function drawJudgmentLine() { gameCtx.shadowBlur = 0; gameCtx.lineWidth = 2; gameCtx.strokeStyle = '#00e5ff'; gameCtx.beginPath(); gameCtx.moveTo(0, HIT_LINE_Y); gameCtx.lineTo(400, HIT_LINE_Y); gameCtx.stroke(); gameCtx.strokeStyle = '#222'; gameCtx.lineWidth = 1; for(let i=0; i<=4; i++) { gameCtx.beginPath(); const x = i*100; gameCtx.moveTo(x, 0); gameCtx.lineTo(x, gameCanvas.height); gameCtx.stroke(); } }
        function drawLaneBeams() { gameCtx.globalCompositeOperation = 'source-over'; for(let i=0; i<4; i++) { if(activeKeys[i]) { const grd = gameCtx.createLinearGradient(0, HIT_LINE_Y, 0, HIT_LINE_Y - 300); grd.addColorStop(0, COLORS[i]); grd.addColorStop(1, "transparent"); gameCtx.fillStyle=grd; gameCtx.globalAlpha=0.2; gameCtx.fillRect(i*100,0,100,HIT_LINE_Y); } } gameCtx.globalCompositeOperation = 'source-over'; gameCtx.globalAlpha=1.0; }

        function showResult() {
            try {
                const rate = totalHits > 0 ? (totalRateSum / totalHits) : 0;
                let rank = "F"; 
                if(rate >= 95) rank = "S"; else if(rate >= 90) rank = "A"; else if(rate >= 80) rank = "B"; else if(rate >= 70) rank = "C";
                const finalScore = Math.round(score);
                const finalScoreStr = finalScore.toString().padStart(6, '0');
                
                if (songParam && diffParam) {
                    const storageKey = `wb_score_${songParam}_${diffParam}`;
                    const bestScore = parseInt(localStorage.getItem(storageKey) || "0");
                    if (finalScore > bestScore) localStorage.setItem(storageKey, finalScoreStr);
                }

                resultOverlay.innerHTML = `
                    <div style="text-align:center; margin-bottom:20px;"><h2 style="margin:0; color:#fff; font-size:32px; text-shadow:0 0 10px #00e5ff;">${songParam ? decodeURIComponent(songParam) : "CUSTOM PLAY"}</h2><div style="color:#aaa; font-size:16px; letter-spacing:2px; margin-top:5px;">${diffParam ? diffParam : "TEST MODE"}</div></div>
                    <div class="${rank} res-rank" style="font-size:140px; margin: 10px 0; line-height:1;">${rank}</div>
                    <div class="res-info" style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:20px; width:80%; max-width:600px; margin-bottom:30px;">
                        <div style="text-align:center"><div style="color:#888; font-size:14px; margin-bottom:5px;">SCORE</div><div style="font-size:28px; font-weight:bold;">${finalScoreStr}</div></div>
                        <div style="text-align:center"><div style="color:#888; font-size:14px; margin-bottom:5px;">RATE</div><div style="font-size:28px; font-weight:bold;">${rate.toFixed(2)}%</div></div>
                        <div style="text-align:center"><div style="color:#888; font-size:14px; margin-bottom:5px;">MAX COMBO</div><div style="font-size:28px; font-weight:bold;">${maxCombo}</div></div>
                    </div>
                    <div style="display:flex; justify-content:space-between; width:90%; max-width:600px; background:rgba(255,255,255,0.05); padding:20px; border-radius:15px; border:1px solid #333;">
                        <div style="text-align:center"><div style="color:#00e5ff; font-weight:bold; font-size:12px; margin-bottom:5px;">PERFECT</div><div style="color:#fff; font-size:20px;">${judgeStats.perfect}</div></div>
                        <div style="text-align:center"><div style="color:#00ff00; font-weight:bold; font-size:12px; margin-bottom:5px;">GREAT</div><div style="color:#fff; font-size:20px;">${judgeStats.great}</div></div>
                        <div style="text-align:center"><div style="color:#ffff00; font-weight:bold; font-size:12px; margin-bottom:5px;">OKAY</div><div style="color:#fff; font-size:20px;">${judgeStats.okay}</div></div>
                        <div style="text-align:center"><div style="color:#FF5252; font-weight:bold; font-size:12px; margin-bottom:5px;">OH...</div><div style="color:#fff; font-size:20px;">${judgeStats.oh}</div></div>
                        <div style="text-align:center"><div style="color:#ff0000; font-weight:bold; font-size:12px; margin-bottom:5px;">MISS</div><div style="color:#fff; font-size:20px;">${judgeStats.miss}</div></div>
                    </div>
                    <button class="btn-close" onclick="closeResult()" style="margin-top:40px;">CONTINUE</button>
                `;
                resultOverlay.style.display = 'flex';
            } catch(e) {
                alert("Result Error: " + e.message);
                location.href='index.html';
            }
        }

        function closeResult() { stopTestMode(); if(songParam) window.location.href="index.html"; }
        const ac = new (window.AudioContext||window.webkitAudioContext)();
        function playTick() { if(ac.state==='suspended') ac.resume(); const o = ac.createOscillator(); const g = ac.createGain(); o.connect(g); g.connect(ac.destination); o.frequency.value = 1200; g.gain.value = 0.1; o.start(); o.stop(ac.currentTime+0.05); }
    </script>
</body>
</html>