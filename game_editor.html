<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>WEB BEAT : EDITOR (Pre-Fire Sync)</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --accent: #00e5ff; --text: #eee; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; user-select: none; }
        
        #sidebar { 
            width: 320px; min-width: 320px; 
            background: var(--panel); padding: 15px; 
            border-right: 1px solid #333; 
            display: flex; flex-direction: column; gap: 12px; 
            z-index: 20; box-shadow: 2px 0 15px rgba(0,0,0,0.7);
            overflow-y: auto; max-height: 100vh;
        }
        #sidebar::-webkit-scrollbar { width: 8px; }
        #sidebar::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        #sidebar::-webkit-scrollbar-thumb:hover { background: var(--accent); }

        h2 { margin: 0 0 10px 0; color: var(--accent); border-bottom: 2px solid var(--accent); padding-bottom: 5px; font-size: 20px; text-shadow: 0 0 10px rgba(0, 229, 255, 0.3); }
        .control-group { display: flex; flex-direction: column; gap: 6px; background: #2a2a2a; padding: 10px; border-radius: 6px; border: 1px solid #333; flex-shrink: 0; }
        .group-title { font-size: 11px; font-weight: bold; color: #aaa; text-transform: uppercase; margin-bottom: 4px; }
        input, select, button { padding: 6px; background: #111; border: 1px solid #444; color: #fff; border-radius: 4px; font-size: 11px; }
        input[type="range"] { padding: 0; cursor: pointer; accent-color: var(--accent); }
        input:focus, select:focus { border-color: var(--accent); outline: none; }
        button { cursor: pointer; font-weight: bold; transition: 0.2s; text-transform: uppercase; }
        button:hover { background: #444; filter: brightness(1.2); }
        button.primary { background: var(--accent); color: #000; border: none; box-shadow: 0 0 10px rgba(0, 229, 255, 0.2); }
        button.test-btn { background: #ff0055; color: white; border: none; font-size: 14px; padding: 12px; box-shadow: 0 0 15px rgba(255, 0, 85, 0.3); }
        
        .row { display: flex; gap: 5px; align-items: center; } .row > * { flex: 1; }
        .val-label { font-size: 12px; color: var(--accent); font-weight: bold; width: 40px; text-align: right; }

        .checkbox-label { display: flex; align-items: center; gap: 8px; cursor: pointer; background: #222; padding: 8px; border-radius: 4px; }
        .checkbox-label input { width: auto; margin: 0; cursor: pointer; accent-color: #7b1fa2; }

        #editor-view { flex: 1; display: flex; flex-direction: column; position: relative; }
        #editor-container { flex: 1; overflow-y: scroll; background: #0a0a0a; display: flex; justify-content: center; }
        #canvas-layer { position: relative; width: 400px; background: #000; cursor: crosshair; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        #play-head { 
            position: absolute; left: 0; width: 100%; height: 2px; 
            background: #ff0055; z-index: 5; display: none; pointer-events: none; 
            box-shadow: 0 0 10px #ff0055; will-change: transform;
        }
        .lane-header { display: flex; width: 400px; margin: 0 auto; background: #222; font-weight: bold; font-size: 12px; text-align: center; border-bottom: 2px solid #444; }
        .lane-header div { flex: 1; padding: 8px 0; border-right: 1px solid #333; color: #888; }

        #game-view { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 50; display: none; flex-direction: column; align-items: center; justify-content: center; }
        #game-canvas-container { position: relative; width: 400px; height: 100%; border-left: 2px solid #333; border-right: 2px solid #333; }
        canvas.game { display: block; width: 100%; height: 100%; }
        
        #game-hud { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; pointer-events: none; z-index: 60; }
        .hud-item { flex: 1; }
        .hud-text { font-family: 'Impact', sans-serif; font-size: 32px; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.5); letter-spacing: 1px; }
        .hud-sub { font-size: 12px; color: #888; font-weight: bold; }
        
        #g-avg-box { position: absolute; bottom: 120px; width: 100%; text-align: center; pointer-events: none; }
        #g-avg { font-family: 'Consolas', monospace; font-size: 14px; font-weight: bold; color: #888; text-shadow: 0 0 2px #000; }
        #test-msg { position: absolute; bottom: 20px; color: #555; font-size: 12px; animation: blink 2s infinite; }
        @keyframes blink { 50% { opacity: 0.3; } }
        
        #result-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 100; display: none; flex-direction: column; align-items: center; justify-content: center; }
        .res-rank { font-family: 'Impact', sans-serif; font-size: 120px; color: #fff; text-shadow: 0 0 20px currentColor; margin-bottom: 20px; }
        .res-rank.S { color: #00e5ff; } .res-rank.A { color: #00ff00; } .res-rank.B { color: #ffff00; } 
        .res-rank.C { color: #ff8800; } .res-rank.F { color: #ff0000; }
        
        .res-info { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px 40px; font-size: 24px; font-weight: bold; margin-bottom: 40px; }
        .res-box { text-align: center; }
        .res-label { color: #888; font-size: 14px; margin-bottom: 5px; } .res-val { color: #fff; font-size: 24px; font-weight: bold; }

        .res-detail { display: flex; justify-content: space-between; width: 90%; max-width: 500px; background: rgba(255,255,255,0.05); padding: 20px; border-radius: 15px; border: 1px solid #333; }
        .detail-item { text-align: center; }
        .detail-label { font-size: 12px; font-weight: bold; margin-bottom: 5px; }
        .detail-val { font-size: 20px; color: #fff; }

        .btn-close { margin-top: 40px; padding: 15px 40px; font-size: 18px; background: #fff; color: #000; border: none; border-radius: 30px; cursor: pointer; font-weight: 900; }
        .btn-close:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(255,255,255,0.5); }

        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; display: none; flex-direction: column; justify-content: center; align-items: center; color: #00e5ff; }
        .loading-text { font-family: 'Impact'; font-size: 40px; margin-bottom: 20px; animation: blink 1s infinite; }
        .btn-start-game { padding: 15px 50px; font-size: 24px; font-weight: bold; background: #ff0055; color: white; border: none; border-radius: 50px; cursor: pointer; display: none; }
        
        input[type="file"] { display: none; }
        .file-label { display: block; padding: 8px; background: #333; text-align: center; border-radius: 4px; cursor: pointer; border: 1px dashed #666; font-size: 12px; }
        .file-label:hover { background: #444; border-color: var(--accent); color: var(--accent); }
        
        #auto-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Impact'; font-size: 80px; color: rgba(123, 31, 162, 0.3); pointer-events: none; display: none; z-index: 55; }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-text" id="loading-msg">LOADING DATA...</div>
        <button id="btn-start-auto" class="btn-start-game" onclick="startAutoPlay()">CLICK TO START</button>
    </div>

    <div id="sidebar">
        <button onclick="location.href='index.html'" style="width:100%; background:#333; margin-bottom:10px; color:#aaa; font-size:11px;">üè† GO TO SELECT</button>

        <h2>üéπ EDITOR v13.0</h2>
        <div class="control-group">
            <div class="group-title">1. Files</div>
            <label class="file-label" for="audioFile">üéµ Load Audio (MP3)</label>
            <input type="file" id="audioFile" accept="audio/*">
            <label class="file-label" for="mapJsonFile" style="margin-top:5px;">üìÇ Load Map (JSON)</label>
            <input type="file" id="mapJsonFile" accept=".json">
        </div>
        <div class="control-group">
            <div class="group-title">2. Map Settings</div>
            <div class="row">
                <input type="number" id="bpm" value="130" placeholder="BPM">
                <input type="number" id="offset" value="0" placeholder="Offset (ms)">
            </div>
        </div>
        <div class="control-group">
            <div class="group-title">3. Edit View</div>
            <div class="row"><span>Zoom:</span><input type="range" id="zoom" min="200" max="1000" step="50" value="400"></div>
            <div class="row"><span>Split:</span><input type="number" id="split" value="16" min="1" max="64" style="width: 60px; text-align: center;"></div>
            <button onclick="addMeasures(4)" style="width:100%; margin-top:5px;">+ Add 4 Bars</button>
        </div>
        <hr style="width:100%; border-color:#333; margin: 5px 0;">
        <div class="control-group">
            <button id="btn-play" class="primary">‚ñ∂ EDIT PLAY (Space)</button>
            <button id="btn-stop">‚èπ STOP</button>
        </div>
        <div class="control-group">
            <div class="group-title">4. Test Play</div>
            <div class="row"><span>Speed:</span><input type="range" id="test-speed" min="1" max="20" step="0.5" value="5.0"><span id="speed-val" class="val-label">x5.0</span></div>
            
            <label class="checkbox-label" style="margin-top:5px;">
                <input type="checkbox" id="chk-auto">
                <span style="font-size:12px; font-weight:bold; color:#d084ff;">ü§ñ Enable Auto Play</span>
            </label>

            <button id="btn-test" class="test-btn" style="margin-top:5px;">üéÆ GAME START (Enter)</button>
        </div>
        
        <button id="btn-export" style="background:#28a745; color:white; margin-top:10px; margin-bottom:10px; padding:12px; border:none; flex-shrink: 0;">üíæ EXPORT JSON</button>
    </div>

    <div id="editor-view">
        <div class="lane-header"><div>D</div><div>F</div><div>J</div><div>K</div></div>
        <div id="editor-container">
            <div id="canvas-layer">
                <div id="play-head"></div>
                <canvas id="gridCanvas" width="400" height="2400"></canvas>
            </div>
        </div>
    </div>

    <div id="game-view">
        <div id="game-canvas-container">
            <canvas id="gameCanvas" class="game"></canvas>
            <div id="game-hud">
                <div class="hud-item" style="text-align:left"><span class="hud-sub">RATE</span><br><span id="g-rate" class="hud-text">100%</span></div>
                <div class="hud-item" style="text-align:center"><span class="hud-sub">SCORE</span><br><span id="g-score" class="hud-text">000000</span></div>
                <div class="hud-item" style="text-align:right"><span class="hud-sub">COMBO</span><br><span id="g-combo" class="hud-text">0</span></div>
            </div>
            <div id="g-avg-box"><div id="g-avg">AVG: 0.0ms</div></div>
            <div id="auto-indicator">AUTO PLAY</div>
            <div id="result-overlay"></div>
        </div>
        <div id="test-msg">[ESC] Back to Editor</div>
    </div>

    <script>
        // ==========================================
        // ‚òÖ [1] ÏÑ§Ï†ï Î∞è Ïù∏Ï¶ù
        // ==========================================
        const SERVER_URL = "https://port-0-vibecoding-rhythmgame-server-mkgu8rcq7cd54e6c.sel3.cloudtype.app/api/score"; 
        const GOOGLE_CLIENT_ID = "143854068141-s09m4p44lfju13dv2gdotoe9hbjfvmmr.apps.googleusercontent.com"; 
        
        // Web Audio API
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)({
            latencyHint: 'interactive', 
            sampleRate: 44100
        });
        const soundBuffers = {};

        async function loadSound(name, url) {
            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                soundBuffers[name] = audioBuffer;
            } catch (e) { console.warn(`Sound error: ${url}`); }
        }
        
        loadSound('hit', 'sfx/hit.mp3');
        loadSound('hold_start', 'sfx/hold_start.mp3');
        loadSound('hold_end', 'sfx/hold_end.mp3');
        loadSound('fc', 'sfx/full_combo.mp3');
        loadSound('ap', 'sfx/all_perfect.mp3');

        // Í∏∞Î≥∏ Ïû¨ÏÉù
        function playSfx(name) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (!soundBuffers[name]) return;
            const source = audioCtx.createBufferSource();
            source.buffer = soundBuffers[name];
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = 0.7;
            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            // ‚òÖ Ïò§ÌÜ† ÌîåÎ†àÏù¥ ÍººÏàò: ÏïûÎ∂ÄÎ∂ÑÏùÑ ÏÇ¥Ïßù ÏûòÎùºÏÑú(0.04s) Ï¶âÍ∞Å Î∞òÏùëÏ≤òÎüº Îì§Î¶¨Í≤å Ìï®
            // ÎßåÏïΩ ÏÜåÎ¶¨Í∞Ä ÏîπÌûàÎ©¥ Ïù¥ Í∞íÏùÑ 0ÏúºÎ°ú Î∞îÍæ∏ÏÑ∏Ïöî.
            source.start(0, 0.04); 
        }

        // ==========================================
        //              EDITOR LOGIC
        // ==========================================
        let audio = new Audio();
        let bpm = 130, offset = 0;
        let measures = []; 
        let measureHeight = 400; 
        
        const BASE_RES = 192; 
        const LANE_COUNT = 4, CANVAS_WIDTH = 400, LANE_WIDTH = 100;
        
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const playHead = document.getElementById('play-head');
        const editorContainer = document.getElementById('editor-container');
        const splitInput = document.getElementById('split');
        const zoomSlider = document.getElementById('zoom');
        const speedSlider = document.getElementById('test-speed');
        const speedVal = document.getElementById('speed-val');
        const offsetInput = document.getElementById('offset');
        const bpmInput = document.getElementById('bpm');

        // Init Editor
        for(let i=0; i<50; i++) measures.push({index: i, notes: []});
        resizeEditor(); drawGrid();

        editorContainer.addEventListener('scroll', () => { requestAnimationFrame(drawGrid); });

        // Game View Elements
        const gameView = document.getElementById('game-view');
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        const resultOverlay = document.getElementById('result-overlay');
        const autoIndicator = document.getElementById('auto-indicator'); 
        
        gameCanvas.width = 400;
        gameCanvas.height = window.innerHeight;
        const HIT_LINE_Y = window.innerHeight * 0.85; 
        const COLORS = ['#FF4081', '#00E676', '#00E676', '#448AFF'];
        
        // Game State Variables
        let isGameTesting = false, gameFinished = false;
        let isAutoMode = false; 
        let gameNotes = [], activeNotes = [], particles = [], recentHits = [], judgments = [];
        let activeKeys = [false, false, false, false];
        let combo = 0, maxCombo = 0, totalHits = 0, totalRateSum = 0, totalOffsetDiff = 0, score = 0;
        let gameAnimId, noteSpeed = 5.0;
        let scorePerHit = 0; 
        
        let startTimestamp = 0;
        const START_DELAY = 2000; 
        let lastNoteEndTime = 0; 
        let totalMaxHits = 0;
        let judgeStats = { perfect: 0, great: 0, okay: 0, oh: 0, miss: 0 };
        let forceFinishTimer = null; 

        const urlParams = new URLSearchParams(window.location.search);
        const songParam = urlParams.get('song');
        const diffParam = urlParams.get('diff');
        const speedParam = urlParams.get('speed');

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        if (songParam && diffParam) {
            document.getElementById('sidebar').style.display = 'none';
            document.getElementById('editor-view').style.display = 'none';
            document.getElementById('loading-screen').style.display = 'flex';
            loadGameData(songParam, diffParam);
        }

        async function loadGameData(song, diff) {
            const loadingMsg = document.getElementById('loading-msg');
            const startBtn = document.getElementById('btn-start-auto');
            try {
                loadingMsg.innerText = `LOADING CHART: ${diff}...`;
                const chartRes = await fetch(`Maps/${song}/${diff}.json`);
                if(!chartRes.ok) throw new Error("Chart not found");
                const chartData = await chartRes.json();
                parseChartData(chartData);

                loadingMsg.innerText = "LOADING AUDIO...";
                audio.src = `Maps/${song}/audio.mp3`;
                audio.load();
                audio.oncanplaythrough = () => { loadingMsg.style.display = 'none'; startBtn.style.display = 'block'; };
                audio.onerror = () => { throw new Error("Audio not found"); };
            } catch (err) {
                alert(`Error: ${err.message}\nPlease run with Live Server!`);
                window.location.href = "index.html"; 
            }
        }

        function parseChartData(data) {
            if(data.bpm) bpm = data.bpm;
            if(data.offset !== undefined) offset = data.offset; else offset = 0;
            measures = []; 
            if(data.measures) {
                const maxIdx = data.measures[data.measures.length-1].index;
                for(let i=0; i<=maxIdx + 5; i++) measures.push({index: i, notes: []});
                data.measures.forEach(m => {
                    const fileSplit = m.split || 32; 
                    const ratio = BASE_RES / fileSplit; 
                    if(measures[m.index]) {
                        measures[m.index].notes = m.notes.map(n => ({
                            lane: n.lane,
                            pos: Math.round(n.pos * ratio), 
                            len: Math.round((n.len || 0) * ratio) 
                        }));
                    }
                });
            }
        }

        function startAutoPlay() { 
            document.getElementById('loading-screen').style.display = 'none'; 
            startTestMode(false); 
        }

        let dragNote = null;
        let isDragging = false;
        let startY = 0;

        document.getElementById('audioFile').addEventListener('change', e => { if(e.target.files[0]) { audio.src = URL.createObjectURL(e.target.files[0]); document.querySelector('label[for="audioFile"]').innerText = "üéµ " + e.target.files[0].name; } });
        document.getElementById('mapJsonFile').addEventListener('change', e => {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    parseChartData(data);
                    resizeEditor(); drawGrid();
                    if(data.bpm) bpmInput.value = data.bpm;
                    if(data.offset) offsetInput.value = data.offset;
                    document.querySelector('label[for="mapJsonFile"]').innerText = "üìÇ " + file.name;
                    alert("Î°úÎìú ÏôÑÎ£å!");
                } catch(err) { alert("Load Error: " + err); }
            };
            reader.readAsText(file);
        });

        document.getElementById('bpm').addEventListener('change', e => bpm = parseFloat(e.target.value));
        offsetInput.addEventListener('input', e => { offset = parseInt(e.target.value) || 0; if(!isEditPlaying && audio.currentTime > 0) updatePlayHeadPos(); });
        splitInput.addEventListener('input', drawGrid);
        zoomSlider.addEventListener('input', e => { measureHeight = parseInt(e.target.value); resizeEditor(); drawGrid(); if(!isEditPlaying && audio.currentTime > 0) updatePlayHeadPos(); });
        speedSlider.addEventListener('input', e => { noteSpeed = parseFloat(e.target.value); speedVal.innerText = "x" + noteSpeed.toFixed(1); });

        document.getElementById('btn-export').addEventListener('click', () => { 
            const data = { 
                title: "Custom Chart", 
                bpm, 
                offset, 
                measures: measures.filter(m => m.notes.length > 0).map(m => ({ ...m, split: BASE_RES })) 
            }; 
            const a = document.createElement('a'); 
            a.href = URL.createObjectURL(new Blob([JSON.stringify(data)], {type:'application/json'})); 
            a.download = 'chart.json'; 
            a.click(); 
        });

        gridCanvas.addEventListener('mousedown', e => {
            if(e.button !== 0) return;
            const rect = gridCanvas.getBoundingClientRect();
            const y = e.clientY - rect.top;
            const x = e.clientX - rect.left;
            const lane = Math.floor(x / LANE_WIDTH);
            const measureIdx = Math.floor(y / measureHeight);
            if(measureIdx >= measures.length) return;

            const split = parseInt(splitInput.value) || 16;
            const relativeY = (y % measureHeight) / measureHeight;
            const snapIdx = Math.round(relativeY * split);
            const pos192 = Math.round(snapIdx * (BASE_RES / split));
            if (pos192 >= BASE_RES) return; 

            const m = measures[measureIdx];
            const existingIdx = m.notes.findIndex(n => n.lane === lane && Math.abs(n.pos - pos192) < 2);

            if(existingIdx === -1) {
                const newNote = { lane, pos: pos192, len: 0 };
                m.notes.push(newNote);
                dragNote = newNote; isDragging = true; startY = y;
                playSfx('hit'); 
            } else {
                dragNote = m.notes[existingIdx]; isDragging = true;
                startY = (measureIdx * measureHeight) + (dragNote.pos / BASE_RES) * measureHeight;
            }
            drawGrid();
        });

        window.addEventListener('mousemove', e => {
            if(!isDragging || !dragNote) return;
            const rect = gridCanvas.getBoundingClientRect();
            const y = e.clientY - rect.top;
            const distPx = Math.max(0, y - startY);
            dragNote.len = Math.round((distPx / measureHeight) * BASE_RES);
            drawGrid();
        });

        window.addEventListener('mouseup', () => { isDragging = false; dragNote = null; });

        gridCanvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            const rect = gridCanvas.getBoundingClientRect();
            const y = e.clientY - rect.top;
            const x = e.clientX - rect.left;
            const lane = Math.floor(x / LANE_WIDTH);
            const measureIdx = Math.floor(y / measureHeight);
            if(measureIdx >= measures.length) return;
            
            const m = measures[measureIdx];
            let idx = m.notes.findIndex(n => n.lane === lane && Math.abs(n.pos - (Math.round(((y % measureHeight)/measureHeight)*(parseInt(splitInput.value)||16))*(BASE_RES/(parseInt(splitInput.value)||16)))) < 5); 
            if(idx === -1) { 
                 const split = parseInt(splitInput.value) || 16;
                 const relativeY = (y % measureHeight) / measureHeight;
                 const pos192 = Math.round(Math.round(relativeY * split) * (BASE_RES / split));
                 idx = m.notes.findIndex(n => n.lane === lane && Math.abs(n.pos - pos192) < 5);
            }

            if(idx !== -1) m.notes.splice(idx, 1);
            drawGrid();
        });

        function resizeEditor() { gridCanvas.height = measures.length * measureHeight; }
        function addMeasures(n) { const start = measures.length; for(let i=0; i<n; i++) measures.push({index: start+i, notes:[]}); resizeEditor(); drawGrid(); }

        let isEditPlaying = false;
        let editAnimId;

        document.getElementById('btn-play').addEventListener('click', toggleEditPlay);
        document.getElementById('btn-stop').addEventListener('click', stopEditPlay);

        function toggleEditPlay() {
            if (!audio.src && !songParam) return alert("Î®ºÏ†Ä MP3 ÌååÏùºÏùÑ Î∂àÎü¨ÏôÄÏ£ºÏÑ∏Ïöî.");
            if (isEditPlaying) { stopEditPlay(); } 
            else {
                offset = parseInt(offsetInput.value) || 0;
                audio.play().then(() => {
                    isEditPlaying = true;
                    playHead.style.display = 'block';
                    editLoop();
                }).catch(e => { console.error(e); alert("Ïû¨ÏÉù Ïò§Î•ò: " + e.message); });
            }
        }

        function stopEditPlay() {
            audio.pause();
            audio.currentTime = 0;
            isEditPlaying = false;
            cancelAnimationFrame(editAnimId);
            playHead.style.display = 'none';
            playHead.style.transform = "translateY(0px)";
            editorContainer.scrollTop = 0;
        }

        function updatePlayHeadPos() {
            const currentMs = audio.currentTime * 1000;
            const chartMs = currentMs - offset;
            const msPerMeasure = (60/bpm)*4*1000;
            const y = Math.max(0, (chartMs / msPerMeasure) * measureHeight);
            playHead.style.transform = `translateY(${y}px)`;
            return y;
        }
        
        function editLoop() {
            if(!isEditPlaying) return;
            const y = updatePlayHeadPos();
            if(y > editorContainer.scrollTop + (window.innerHeight/2)) {
                editorContainer.scrollTop = y - (window.innerHeight/2);
            }
            editAnimId = requestAnimationFrame(editLoop);
        }

        function drawGrid() {
            gridCtx.fillStyle = "#000"; gridCtx.fillRect(0,0,400, gridCanvas.height);
            const split = parseInt(splitInput.value) || 16;
            const cellH = measureHeight / split;
            const scrollY = editorContainer.scrollTop;
            const viewHeight = editorContainer.clientHeight;
            const startMeasureIdx = Math.max(0, Math.floor(scrollY / measureHeight));
            const endMeasureIdx = Math.min(measures.length - 1, Math.ceil((scrollY + viewHeight) / measureHeight));

            for (let i = startMeasureIdx; i <= endMeasureIdx; i++) {
                const m = measures[i];
                const y = i * measureHeight;
                gridCtx.lineWidth = 1;
                for(let j=0; j<split; j++) {
                    const ly = y + j*cellH;
                    gridCtx.strokeStyle = (j===0) ? "#888" : (j%(split/4)===0 ? "#555" : "#222");
                    gridCtx.beginPath(); gridCtx.moveTo(0, ly); gridCtx.lineTo(400, ly); gridCtx.stroke();
                }
                m.notes.forEach(n => {
                    const ny = y + (n.pos/BASE_RES)*measureHeight;
                    const visualH = 10; 
                    if(n.len > 0) {
                        const tailY = ny + (n.len/BASE_RES)*measureHeight;
                        gridCtx.fillStyle = COLORS[n.lane];
                        gridCtx.globalAlpha = 0.5;
                        gridCtx.fillRect(n.lane*100+10, ny + visualH/2, 80, tailY - ny);
                        gridCtx.globalAlpha = 1.0;
                    }
                    gridCtx.fillStyle = COLORS[n.lane]; 
                    gridCtx.fillRect(n.lane*100+1, ny, 98, visualH);
                });
                gridCtx.fillStyle="#fff"; gridCtx.font="12px Arial"; gridCtx.fillText(i+1, 5, y+15);
                gridCtx.strokeStyle="#444"; gridCtx.lineWidth=1;
                for(let k=1; k<4; k++) { gridCtx.beginPath(); gridCtx.moveTo(k*100,y); gridCtx.lineTo(k*100, y + measureHeight); gridCtx.stroke(); }
            }
        }

        // ==========================================
        // ¬† ¬† ¬† ¬† ¬† ¬† ¬†GAME LOGIC
        // ==========================================
        
        document.getElementById('btn-test').addEventListener('click', () => {
            const isAuto = document.getElementById('chk-auto').checked;
            startTestMode(isAuto);
        });
        
        function startTestMode(auto) {
            if(!audio.src && !songParam) return alert("MP3 Missing!");
            if(!songParam) offset = parseInt(offsetInput.value) || 0;
            
            if(isNaN(bpm) || bpm <= 0) bpm = 130;

            const userGlobalOffset = parseInt(localStorage.getItem('wb_global_offset') || 0);
            offset += userGlobalOffset;

            if (speedParam) noteSpeed = parseFloat(speedParam);
            else noteSpeed = parseFloat(speedSlider.value);

            isAutoMode = auto;
            if(autoIndicator) autoIndicator.style.display = isAutoMode ? 'block' : 'none';

            gameNotes = [];
            totalMaxHits = 0; 
            lastNoteEndTime = 0;
            judgeStats = { perfect: 0, great: 0, okay: 0, oh: 0, miss: 0 }; 

            const msPerMeasure = (60000 / bpm) * 4;
            measures.forEach(m => {
                m.notes.forEach(n => {
                    const time = (m.index * msPerMeasure) + (n.pos / BASE_RES) * msPerMeasure;
                    const duration = (n.len / BASE_RES) * msPerMeasure;
                    
                    const noteTime = time + offset; 
                    const noteEndTime = noteTime + duration;
                    
                    if (noteEndTime > lastNoteEndTime) lastNoteEndTime = noteEndTime;

                    gameNotes.push({ 
                        time: noteTime, 
                        endTime: noteEndTime, 
                        lane: n.lane, 
                        len: n.len, 
                        hit: false, holding: false, finished: false,
                        audioPlayed: false // ‚òÖ ÏÜåÎ¶¨ Ïû¨ÏÉù Ï≤¥ÌÅ¨Ïö© ÌîåÎûòÍ∑∏
                    });
                    totalMaxHits++; 
                    if(n.len > 0) totalMaxHits++; 
                });
            });
            gameNotes.sort((a,b) => a.time - b.time);
            scorePerHit = totalMaxHits > 0 ? (1000000 / totalMaxHits) : 0;

            stopEditPlay();
            gameView.style.display = 'flex'; 
            resultOverlay.style.display = 'none';
            if(!songParam) document.getElementById('sidebar').style.display = 'none';
            
            activeNotes = []; particles = []; recentHits = []; judgments = []; activeKeys = [false,false,false,false];
            combo = 0; maxCombo = 0; totalHits = 0; totalRateSum = 0; totalOffsetDiff = 0; score = 0;
            updateGameHUD();
            
            isGameTesting = true; gameFinished = false;
            
            gameState = 'COUNTDOWN';
            startTimestamp = Date.now();
            gameStartTime = Date.now();
            audio.currentTime = 0;

            const absoluteEndTime = 2000 + lastNoteEndTime + 4000;
            if (forceFinishTimer) clearTimeout(forceFinishTimer);
            forceFinishTimer = setTimeout(() => {
                finishGame();
            }, absoluteEndTime);

            gameLoop();
        }

        function stopTestMode() {
            isGameTesting = false; audio.pause(); audio.currentTime = 0;
            cancelAnimationFrame(gameAnimId);
            if (forceFinishTimer) clearTimeout(forceFinishTimer);
            
            if (songParam) window.location.href = "index.html"; 
            else { gameView.style.display = 'none'; document.getElementById('sidebar').style.display = 'flex'; }
        }

        function finishGame() {
            if (!isGameTesting || gameFinished) return;
            gameFinished = true;
            if (forceFinishTimer) clearTimeout(forceFinishTimer);
            audio.pause();
            setTimeout(showResult, 500);
        }

        const KEY_MAP = ['d', 'f', 'j', 'k'];
        window.addEventListener('keydown', e => {
            if(e.code === 'Space' && !isGameTesting && !songParam) { e.preventDefault(); toggleEditPlay(); }
            if(e.code === 'Enter' && !isGameTesting && !songParam) {
                const isAuto = document.getElementById('chk-auto').checked;
                startTestMode(isAuto);
            }
            if(e.code === 'Escape' && isGameTesting && !songParam) stopTestMode();
            
            if(isGameTesting && !gameFinished && !isAutoMode) {
                const lane = KEY_MAP.indexOf(e.key.toLowerCase());
                if(lane !== -1 && !activeKeys[lane]) { activeKeys[lane] = true; checkHit(lane); }
            }
        });
        window.addEventListener('keyup', e => {
            if(isGameTesting && !gameFinished && !isAutoMode) {
                const lane = KEY_MAP.indexOf(e.key.toLowerCase());
                if(lane !== -1) { activeKeys[lane] = false; checkRelease(lane); }
            }
        });

        // ==========================================
        // ‚òÖ [ÌïµÏã¨] Í≤åÏûÑ Î£®ÌîÑ
        // ==========================================
        function gameLoop() {
            if(!isGameTesting || gameFinished) return;
            gameAnimId = requestAnimationFrame(gameLoop);
            
            const now = Date.now();
            let currentTime = -9999;

            if (gameState === 'COUNTDOWN') {
                currentTime = (now - startTimestamp) - START_DELAY; 
                if (now - startTimestamp >= START_DELAY) {
                    gameState = 'WAIT_AUDIO';
                    audio.play().catch(e => console.error("Play Fail", e));
                }
            } else if (gameState === 'WAIT_AUDIO') {
                currentTime = 0;
                if (audio.currentTime > 0) gameState = 'PLAYING';
            } else if (gameState === 'PLAYING') {
                currentTime = audio.currentTime * 1000;
            }

            if (gameNotes.length === 0 && activeNotes.length === 0) {
                if (audio.ended || currentTime > lastNoteEndTime + 1000) {
                    finishGame();
                }
            }

            gameCtx.fillStyle = '#000'; gameCtx.fillRect(0, 0, 400, gameCanvas.height);
            drawLaneBeams();
            drawJudgmentLine();

            const NOTE_SPEED_PX = 100 * noteSpeed; 
            while(gameNotes.length > 0 && gameNotes[0].time - 2000 < currentTime) activeNotes.push(gameNotes.shift());

            // ‚òÖ Ïò§ÌÜ† ÌîåÎ†àÏù¥ Î°úÏßÅ (ÏÜåÎ¶¨ÏôÄ ÌôîÎ©¥Ïùò ÌÉÄÏù¥Î∞ç Î∂ÑÎ¶¨!)
            if (isAutoMode) {
                activeNotes.forEach(n => {
                    // 1. ÏÜåÎ¶¨ Î®ºÏ†Ä Ïû¨ÏÉù (45ms ÎØ∏Î¶¨ Î™ÖÎ†π ÎÇ¥Î†§ÏÑú ÎîúÎ†àÏù¥ ÏÉÅÏáÑ)
                    if (!n.audioPlayed && currentTime >= n.time - 120) {
                        n.audioPlayed = true; 
                        if(n.len > 0) playSfx('hold_start');
                        else playSfx('hit');
                    }

                    // 2. ÌôîÎ©¥ÏùÄ Ï†ïÎ∞ïÏóê ÌÑ∞Ïßê (0ms)
                    if (!n.hit && currentTime >= n.time) {
                        n.hit = true; n.holding = true;
                        if(n.len === 0) n.finished = true;
                        
                        activeKeys[n.lane] = true; 
                        createParticles(n.lane);
                        combo++; totalHits++; score += scorePerHit; totalRateSum += 100;
                        judgeStats.perfect++; 
                        updateGameHUD(); showJudge("PERFECT", n.lane, "#00e5ff");
                        
                        if(n.len === 0) setTimeout(() => { if(!n.holding) activeKeys[n.lane] = false; }, 50);
                    }
                    
                    // 3. Î°±ÎÖ∏Ìä∏ Ï¢ÖÎ£å
                    if (n.hit && n.len > 0 && !n.finished) {
                        activeKeys[n.lane] = true;
                        if (currentTime >= n.endTime) {
                            n.finished = true;
                            activeKeys[n.lane] = false;
                            totalHits++; score += scorePerHit; totalRateSum += 100;
                            combo++; judgeStats.perfect++;
                            createParticles(n.lane); updateGameHUD(); playSfx('hold_end');
                        }
                    }
                });
            }

            for(let i=0; i<activeNotes.length; i++) {
                let n = activeNotes[i];
                const headY = HIT_LINE_Y - ((n.time - currentTime) / 1000 * NOTE_SPEED_PX);
                let tailY = headY;
                if (n.len > 0) tailY = HIT_LINE_Y - ((n.endTime - currentTime) / 1000 * NOTE_SPEED_PX);

                if (tailY > gameCanvas.height) {
                    if (!n.finished) {
                        n.finished = true;
                        if (!n.hit) { 
                            n.hit = true; combo = 0; totalHits++; judgeStats.miss++; 
                            if(n.len > 0) totalHits++; 
                            updateGameHUD(); showJudge("MISS", n.lane, "#ff5555");
                        }
                    }
                    continue;
                }

                if(!isAutoMode && !n.hit && !n.finished && currentTime > n.time + 250) { 
                    n.hit = true; n.finished = true; combo = 0; totalHits++; 
                    judgeStats.miss++; 
                    if(n.len > 0) totalHits++; 
                    updateGameHUD(); showJudge("MISS", n.lane, "#ff5555");
                    checkFinish();
                } 
                
                if (!isAutoMode && n.hit && n.len > 0 && !n.finished) {
                    if (activeKeys[n.lane]) {
                        if (currentTime >= n.endTime) {
                            n.finished = true; totalHits++; totalRateSum += 100; score += scorePerHit; 
                            combo++; judgeStats.perfect++; updateGameHUD(); createParticles(n.lane);
                            playSfx('hold_end'); checkFinish();
                        }
                    }
                }

                if (!n.finished) {
                    if (n.len > 0) {
                        const drawHeadY = n.hit ? HIT_LINE_Y : headY;
                        const clippedHeadY = Math.min(gameCanvas.height, drawHeadY);
                        const clippedTailY = Math.max(-100, tailY);
                        const bodyH = clippedHeadY - clippedTailY;
                        if (bodyH > 0 && clippedHeadY > -50) {
                            gameCtx.fillStyle = "rgba(255, 255, 255, 0.5)";
                            gameCtx.fillRect(n.lane * 100 + 10, clippedTailY, 80, bodyH);
                        }
                    }
                    if (!n.hit && headY > -50 && headY < gameCanvas.height) {
                        gameCtx.fillStyle = COLORS[n.lane]; 
                        gameCtx.fillRect(n.lane * 100 + 5, headY - 12, 90, 24);
                        gameCtx.fillStyle = "rgba(255,255,255,0.7)"; 
                        gameCtx.fillRect(n.lane * 100 + 5, headY - 12, 90, 6);
                    }
                }
            }
            activeNotes = activeNotes.filter(n => !n.finished);
            drawParticles(); drawGameFX(); drawHitErrorBar();
        }

        function checkFinish() { }

        function checkHit(lane) {
            let currentTime = 0;
            if (gameState === 'PLAYING' && audio.currentTime > 0) currentTime = audio.currentTime * 1000;
            else currentTime = (Date.now() - startTimestamp) - START_DELAY;

            const HIT_WINDOW = 150; 
            const candidates = activeNotes.filter(n => n.lane === lane && !n.hit && !n.finished && Math.abs(currentTime - n.time) <= HIT_WINDOW);
            if (candidates.length === 0) return;

            const n = candidates.reduce((prev, curr) => prev.time < curr.time ? prev : curr);
            const absDiff = Math.abs(currentTime - n.time);

            n.hit = true; n.holding = true; if (n.len === 0) n.finished = true;
            totalHits++; 
            if (n.len > 0) playSfx('hold_start'); else playSfx('hit');

            let judge="MISS", clr="#888", rate=0;
            if(absDiff <= 45) { judge="PERFECT"; clr="#00e5ff"; rate=100; judgeStats.perfect++; }
            else if(absDiff <= 90) { judge="GREAT"; clr="#00ff00"; rate=90; judgeStats.great++; }
            else if(absDiff <= 150) { judge="OKAY"; clr="#ffff00"; rate=50; judgeStats.okay++; }
            
            if(rate > 0) { combo++; if(combo > maxCombo) maxCombo = combo; score += (rate / 100) * scorePerHit; createParticles(lane); } 
            else { combo = 0; }
            
            totalRateSum += rate; updateGameHUD(); showJudge(judge, lane, clr); 
            recentHits.push({ diff: currentTime - n.time, color: clr, life: 600, maxLife: 600 });
            if(n.finished) checkFinish();
        }

        function checkRelease(lane) {
            const n = activeNotes.find(n => n.lane === lane && n.hit && !n.finished && n.len > 0);
            if (n) {
                let currentTime = 0;
                if (gameState === 'PLAYING' && audio.currentTime > 0) currentTime = audio.currentTime * 1000;
                else currentTime = (Date.now() - startTimestamp) - START_DELAY;

                const remaining = n.endTime - currentTime; 
                const totalDuration = n.endTime - n.time;
                const safeZone = Math.max(300, totalDuration * 0.5); 
                
                if (remaining > safeZone) { 
                    n.finished = true; combo = 0; totalHits++; judgeStats.miss++; 
                    updateGameHUD(); showJudge("BREAK", lane, "#555");
                } else {
                    n.finished = true; totalHits++; score += scorePerHit; totalRateSum += 100; 
                    combo++; judgeStats.perfect++; 
                    createParticles(lane); updateGameHUD(); showJudge("PERFECT", lane, "#00e5ff");
                    playSfx('hold_end');
                }
                checkFinish();
            }
        }

        function updateGameHUD() {
            document.getElementById('g-combo').innerText = combo;
            document.getElementById('g-score').innerText = Math.round(score).toString().padStart(6, '0');
            const rate = totalHits > 0 ? (totalRateSum / (totalHits * 100)) * 100 : 100;
            document.getElementById('g-rate').innerText = rate.toFixed(2) + "%";
            const avg = totalHits > 0 ? (totalOffsetDiff/totalHits).toFixed(1) : "0.0";
            document.getElementById('g-avg').innerText = `AVG: ${avg}ms`;
        }
        function showJudge(text, lane, color) { judgments.push({text, x: lane*100+50, y: HIT_LINE_Y-100, life: 40, maxLife: 40, color}); }
        function drawGameFX() { for(let i=judgments.length-1; i>=0; i--) { const j = judgments[i]; gameCtx.save(); gameCtx.globalAlpha = j.life/j.maxLife; gameCtx.fillStyle = j.color; gameCtx.font="900 24px Arial"; gameCtx.textAlign="center"; gameCtx.fillText(j.text, j.x, j.y); gameCtx.restore(); j.life--; if(j.life<=0) judgments.splice(i,1); } }
        function drawHitErrorBar() { const cx = 200, cy = HIT_LINE_Y + 50, width = 300; gameCtx.fillStyle = "rgba(50, 50, 50, 0.8)"; gameCtx.fillRect(cx - width/2, cy - 2, width, 4); gameCtx.fillStyle = "#fff"; gameCtx.fillRect(cx - 1, cy - 8, 2, 16); for(let i = recentHits.length - 1; i >= 0; i--) { const h = recentHits[i]; const px = (h.diff / 100) * (width / 2); let drawX = Math.max(cx - width/2, Math.min(cx + width/2, cx + px)); gameCtx.fillStyle = h.color; gameCtx.globalAlpha = h.life / h.maxLife; gameCtx.fillRect(drawX - 1, cy - 6, 2, 12); gameCtx.globalAlpha = 1.0; h.life--; if(h.life <= 0) recentHits.splice(i, 1); } }
        function createParticles(lane) { for(let i=0; i<4; i++) particles.push({x:lane*100+50, y:HIT_LINE_Y, vx:(Math.random()-0.5)*10, vy:(Math.random()-1)*10-2, life:1, color:COLORS[lane]}); }
        function drawParticles() { for(let i=particles.length-1; i>=0; i--){ let p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.5; p.life-=0.05; if(p.life<=0) particles.splice(i,1); else { gameCtx.globalAlpha=p.life; gameCtx.fillStyle=p.color; gameCtx.fillRect(p.x,p.y,5,5); } } }
        function drawJudgmentLine() { gameCtx.shadowBlur = 0; gameCtx.lineWidth = 2; gameCtx.strokeStyle = '#00e5ff'; gameCtx.beginPath(); gameCtx.moveTo(0, HIT_LINE_Y); gameCtx.lineTo(400, HIT_LINE_Y); gameCtx.stroke(); gameCtx.strokeStyle = '#222'; gameCtx.lineWidth = 1; for(let i=0; i<=4; i++) { gameCtx.beginPath(); const x = i*100; gameCtx.moveTo(x, 0); gameCtx.lineTo(x, gameCanvas.height); gameCtx.stroke(); } }
        function drawLaneBeams() { gameCtx.globalCompositeOperation = 'source-over'; for(let i=0; i<4; i++) { if(activeKeys[i]) { const grd = gameCtx.createLinearGradient(0, HIT_LINE_Y, 0, HIT_LINE_Y - 300); grd.addColorStop(0, COLORS[i]); grd.addColorStop(1, "transparent"); gameCtx.fillStyle=grd; gameCtx.globalAlpha=0.2; gameCtx.fillRect(i*100,0,100,HIT_LINE_Y); } } gameCtx.globalCompositeOperation = 'source-over'; gameCtx.globalAlpha=1.0; }

        function showResult() {
            try {
                const rate = totalHits > 0 ? (totalRateSum / totalHits) : 0;
                let rank = "F"; 
                if(rate >= 95) rank = "S"; else if(rate >= 90) rank = "A"; else if(rate >= 80) rank = "B"; else if(rate >= 70) rank = "C";
                const finalScore = Math.round(score);
                const finalScoreStr = finalScore.toString().padStart(6, '0');
                
                if (songParam && diffParam) {
                    const storageKey = `wb_score_${songParam}_${diffParam}`;
                    const bestScore = parseInt(localStorage.getItem(storageKey) || "0");
                    if (finalScore > bestScore) localStorage.setItem(storageKey, finalScoreStr);
                }

                resultOverlay.innerHTML = `
                    <div style="text-align:center; margin-bottom:20px;"><h2 style="margin:0; color:#fff; font-size:32px; text-shadow:0 0 10px #00e5ff;">${songParam ? decodeURIComponent(songParam) : "CUSTOM PLAY"}</h2><div style="color:#aaa; font-size:16px; letter-spacing:2px; margin-top:5px;">${diffParam ? diffParam : "TEST MODE"}</div></div>
                    <div class="${rank} res-rank" style="font-size:140px; margin: 10px 0; line-height:1;">${rank}</div>
                    <div class="res-info" style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:20px; width:80%; max-width:600px; margin-bottom:30px;">
                        <div style="text-align:center"><div style="color:#888; font-size:14px; margin-bottom:5px;">SCORE</div><div style="font-size:28px; font-weight:bold;">${finalScoreStr}</div></div>
                        <div style="text-align:center"><div style="color:#888; font-size:14px; margin-bottom:5px;">RATE</div><div style="font-size:28px; font-weight:bold;">${rate.toFixed(2)}%</div></div>
                        <div style="text-align:center"><div style="color:#888; font-size:14px; margin-bottom:5px;">MAX COMBO</div><div style="font-size:28px; font-weight:bold;">${maxCombo}</div></div>
                    </div>
                    <div style="display:flex; justify-content:space-between; width:90%; max-width:600px; background:rgba(255,255,255,0.05); padding:20px; border-radius:15px; border:1px solid #333;">
                        <div style="text-align:center"><div style="color:#00e5ff; font-weight:bold; font-size:12px; margin-bottom:5px;">PERFECT</div><div style="color:#fff; font-size:20px;">${judgeStats.perfect}</div></div>
                        <div style="text-align:center"><div style="color:#00ff00; font-weight:bold; font-size:12px; margin-bottom:5px;">GREAT</div><div style="color:#fff; font-size:20px;">${judgeStats.great}</div></div>
                        <div style="text-align:center"><div style="color:#ffff00; font-weight:bold; font-size:12px; margin-bottom:5px;">OKAY</div><div style="color:#fff; font-size:20px;">${judgeStats.okay}</div></div>
                        <div style="text-align:center"><div style="color:#FF5252; font-weight:bold; font-size:12px; margin-bottom:5px;">OH...</div><div style="color:#fff; font-size:20px;">${judgeStats.oh}</div></div>
                        <div style="text-align:center"><div style="color:#ff0000; font-weight:bold; font-size:12px; margin-bottom:5px;">MISS</div><div style="color:#fff; font-size:20px;">${judgeStats.miss}</div></div>
                    </div>
                    <button class="btn-close" onclick="closeResult()" style="margin-top:40px;">CONTINUE</button>
                `;
                resultOverlay.style.display = 'flex';
            } catch(e) {
                alert("Result Error: " + e.message);
                location.href='index.html';
            }
        }

        function closeResult() { stopTestMode(); if(songParam) window.location.href="index.html"; }
        const ac = new (window.AudioContext||window.webkitAudioContext)();
        function playTick() { if(ac.state==='suspended') ac.resume(); const o = ac.createOscillator(); const g = ac.createGain(); o.connect(g); g.connect(ac.destination); o.frequency.value = 1200; g.gain.value = 0.1; o.start(); o.stop(ac.currentTime+0.05); }
    </script>
</body>
</html>